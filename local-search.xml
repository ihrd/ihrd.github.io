<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2023/06/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/06/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<img src="image-20230521095918235.png" alt="" style="zoom:28%;" /><h2 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1. 快速排序"></a>1. 快速排序</h2><h3 id="1-1-算法思想-——-分治"><a href="#1-1-算法思想-——-分治" class="headerlink" title="1.1 算法思想 —— 分治"></a>1.1 算法思想 —— 分治</h3><img src="image-20230521103553300.png" alt="" style="zoom:80%;" /><ol><li><p>确定分界点 x</p><p>常用方式：取边界（<code>q[l]/q[r]</code>）、取中间值（<code>q[(j+r)/2]</code>）、区间内随机一个数</p></li><li><p><strong>调整区间 ☆（重难点）</strong></p><p>把区间分为两部分，使得左边区间中的数都小于等于 x，右边区间中的数都大于等于 x</p></li><li><p>递归处理左右两段</p></li></ol><p><strong>第二步 调整区间实现方法</strong></p><ul><li><p>方法一：暴力法（思想简单、占用额外空间）</p><ul><li><blockquote><p>空间复杂度$O(n)$</p></blockquote></li><li><p>首先，开两个额外的数组<code>a[]</code>、<code>b[]</code>。</p></li><li><p>然后，扫描<code>q[l]~q[r]</code>的每一个数。如果<code>q[i]&lt;x</code>，则把其插入到数组<code>a[]</code>中；如果<code>q[i]&gt;x</code>，则把其插入到数组<code>b[]</code>中。</p></li><li><p>最后，先遍历数组<code>a[]</code>，再遍历数组<code>b[]</code>，把数组中的数依次存储到数组<code>q[]</code>中。</p></li></ul></li><li><p>方法二：双指针法（优美而简洁）</p><ul><li><blockquote><p>要点：在任何时刻，<code>i</code>指针左边所有的数都一定小于等于x，<code>j</code>指针右边的数都一定大于等于x。</p><p>原因：当<code>i</code>指针在遍历时，如果当前数满足小于等于x的条件时，则<code>i</code>会指向下一个数；如果当前数不满足小于等于x的条件时，<code>i</code>指针会等待<code>j</code>指针找到一个小于等于x的数与之交换，从而使得当前数也满足小于等于x的条件。最终，<code>i</code>指针左侧所有的数都一定小于等于x。对于<code>j</code>指针，同理。</p></blockquote></li><li><p>定义两个指针<code>i</code>和<code>j</code>，分别指向要排序的数组<code>q</code>的两端</p><img src="image-20230521105605347.png" alt="" style="zoom:80%;" /></li><li><p>两个指针分别往中间走，即<code>i++</code>和<code>j--</code>。</p><ul><li><p>首先，移动<code>i</code>指针。当<code>i</code>指向的值满足<code>q[i]&lt;=x</code>时，<code>i</code>做自增运算，即<code>i++</code>；否则，<code>i</code>指针停止移动。</p></li><li><p>然后，移动<code>j</code>指针。当<code>j</code>指向的值满足<code>q[j]&gt;=x</code>时，<code>j</code>做自减运算，即<code>j--</code>；否则，<code>j</code>指针停止移动。</p><img src="image-20230521105749174.png" alt="" style="zoom:80%;" /></li></ul></li><li><p>做完上述指针移动操作后，<code>i</code>指针左边所有的值都满足<code>q[]&lt;=x</code>，<code>j</code>指针右边所有的值都满足<code>q[]&gt;=x</code>，但此时<code>q[i]&gt;x</code>且<code>q[j]&lt;x</code>。为满足要求（调整区间），需要通过交换<code>i</code>和<code>j</code>指向的值，使得<code>i</code>指向的值满足<code>q[i]&lt;=x</code>、<code>j</code>指向的值满足<code>q[j]&gt;=x</code>，从而使程序能够继续运行。</p><img src="image-20230521110143131.png" alt="" style="zoom:80%;" /></li><li><p>当<code>i&gt;j</code>时，说明已经得到了两端调整后的区间（此时，<code>i</code>指针左边的值都满足小于等于x，<code>j</code>指针右边的值都满足大于等于x）</p><img src="image-20230521110309585.png" alt="" style="zoom:80%;" /></li></ul></li></ul><h3 id="1-2-模板"><a href="#1-2-模板" class="headerlink" title="1.2 模板"></a>1.2 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-关于边界问题"><a href="#1-3-关于边界问题" class="headerlink" title="1.3 关于边界问题"></a>1.3 关于边界问题</h3><p><strong>正确代码1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><img src="image-20230521233936246.png" alt="" style="zoom:100%;" /><p><strong>错误代码1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[r];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><img src="image-20230521235108658.png" alt="" style="zoom:100%;" /><p><strong>正确代码2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[r];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><img src="image-20230521234619935.png" alt="" style="zoom:100%;" /><p><strong>错误代码2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><img src="image-20230521234340627.png" alt="" style="zoom:100%;" /><h2 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2. 归并排序"></a>2. 归并排序</h2><h3 id="2-1-算法思想-——-分治"><a href="#2-1-算法思想-——-分治" class="headerlink" title="2.1 算法思想 —— 分治"></a>2.1 算法思想 —— 分治</h3><ol><li><p>确定分界点</p><p>以数组的中间点为分界线，分为左右两部分。<code>mid = (l + r) / 2</code></p></li><li><p>递归排序左右两部分</p></li><li><p><strong>归并 —— 合二为一</strong></p></li></ol><p><strong>第三步的实现方法</strong></p><p>- </p><h3 id="2-2-模板"><a href="#2-2-模板" class="headerlink" title="2.2 模板"></a>2.2 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
