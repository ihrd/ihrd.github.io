<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AcWing143. 最大异或对</title>
    <link href="/2023/07/22/%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9/"/>
    <url>/2023/07/22/%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1>AcWing143. 最大异或对</h1><blockquote><p>原题链接：<a href="https://www.acwing.com/problem/content/145/">143. 最大异或对 - AcWing题库</a></p></blockquote><h2 id="一、题目">一、题目</h2><p>在给定的 $N$ 个整数 $A_1，A_2……A_N$ 中选出两个进行 $xor$（异或）运算，得到的结果最大是多少？</p><h4 id="输入格式">输入格式</h4><p>第一行输入一个整数 $N$。</p><p>第二行输入 $N$ 个整数 $A_1～A_N$。</p><h4 id="输出格式">输出格式</h4><p>输出一个整数表示答案。</p><h4 id="数据范围">数据范围</h4><p>$1≤N≤10^5$<br>$0≤A_i&lt;2^{31}$</p><h4 id="输入样例：">输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs input">3<br>1 2 3<br></code></pre></td></tr></table></figure><h4 id="输出样例：">输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">3<br></code></pre></td></tr></table></figure><h2 id="二、分析">二、分析</h2><p>**异或运算（同 $0$ 异 $1$）：**异或运算是一种二进制位运算，也称异或操作。如果两个对应的二进制位相同，则异或的结果为 $0$；如果两个对应的二进制位不同，则异或结果为 $1$。</p><img src="https://s1.ax1x.com/2023/07/23/pCq6yp8.png" style="zoom: 50%;"><p>**性质：**对于一个二进制数，如果要找到与其异或最大的数，则使高位与要找的数的对应位异或为 $1$。</p><img src="https://s1.ax1x.com/2023/07/23/pCq661S.png" style="zoom:50%;"><hr><p><strong>暴力做法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-comment">// 枚举第一个数</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) <span class="hljs-comment">// 枚举第二个数</span><br>        ans = <span class="hljs-built_in">max</span>(ans, a[i] ^ a[j]);<br>&#125;<br></code></pre></td></tr></table></figure><p>第 $2$ 层<code>for</code>循环的含义：从<code>a[i+1]</code>到<code>a[n-1]</code>找到一个和<code>a[i]</code>异或最大的一个结果，内层循环的时间复杂度为 $O(n)$，总体时间复杂度为 $O(n^2)$。可以通过Trie树对内层<code>for</code>循环优化。</p><p><strong>Trie树优化：</strong></p><p>由题意知，每个整数都可以用 $31$ 位的二进制串来表示，再结合上面提到的异或的性质，则可以把每个整数表示成Trie树中的一个序列（其中，每个序列的存储是从高位开始的，即离根节点越近的结点在二进制数中的位数越高）。</p><p>当我们求解与<code>a[i]</code>异或的最大值时，需要遍历我们构造的Trie树，每次尽可能的往和当前位不同的位（图中紫色路径）上走。当走到叶节点的时候，我们就找到与当前<code>a[i]</code>异或最大的结果了。</p><p>此时，内层查找代码的时间复杂度为 $O(31)$，则总体时间复杂度为 $O(n)$。</p><h2 id="三、题解">三、题解</h2>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie树</tag>
      
      <tag>异或</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用conda命令</title>
    <link href="/2023/07/17/%E5%B8%B8%E7%94%A8conda%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/07/17/%E5%B8%B8%E7%94%A8conda%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1>常用Conda命令</h1><p><strong>查看已经创建的虚拟环境：</strong><code>conda env list</code></p><p><strong>创建conda虚拟环境：</strong><code>conda create -n your_env_name python=x.x </code></p><p><strong>激活conda虚拟环境：</strong><code>conda activate your_env_name</code></p><p><strong>删除conda虚拟环境：</strong><code>conda remove -n your_env_name --all</code></p><hr><p><strong>查看当前conda环境中安装了哪些包：</strong><code>conda list</code></p><p><strong>在虚拟环境中安装包：</strong><code>conda install -n your_env_name [package]</code></p><p><strong>检查更新当前conda：</strong><code>conda update conda</code></p>]]></content>
    
    
    <categories>
      
      <category>Conda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>conda命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing3717. 整数序列</title>
    <link href="/2023/07/16/%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <url>/2023/07/16/%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1>AcWing3717. 整数序列</h1><blockquote><p>原题链接：<a href="https://www.acwing.com/problem/content/description/3720/">3717. 整数序列 - AcWing题库</a></p></blockquote><h2 id="一、题目">一、题目</h2><p>很多整数可以由一段连续的<strong>正整数</strong>序列（至少两个数）相加而成，比如$25=3+4+5+6+7=12+13$。</p><p>输入一个整数 $N$，输出 $N$ 的全部正整数序列，如果没有则输出 <code>NONE</code>。</p><p><strong>输入格式</strong></p><p>一个整数 $N$。</p><p><strong>输出格式</strong></p><p>每行输出一个满足条件的整数序列。</p><p>序列内部元素从小到大排序。</p><p>优先输出首项更小的序列。</p><p><strong>数据范围</strong></p><p>$2≤N≤10^7$</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs input">25<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs output">3 4 5 6 7<br>12 13<br></code></pre></td></tr></table></figure><h2 id="二、分析">二、分析</h2><h4 id="二分">二分</h4><p>枚举首项，通过二分找到尾项，使满足 $n=\frac{(a+b)n}{2}$。其中，$a$ 为首项、$b$ 为尾项。</p><h4 id="数学知识（推公式-分解质因数）">数学知识（推公式 + 分解质因数）</h4><blockquote><p>等差数列前 $n$ 项和公式：$<br>S_n=na_1+{\frac{n\left( n-1 \right)}{2}\cdot d}<br>$</p></blockquote><p>设答案序列首项为 $a$，共 $k$ 项，且有题目知公差为 $1$，则所求的序列为 $a$、$a+1$、$a+2$、$…$、$a+k-1$。</p><p>由等差数列前 $n$ 项和公式得：$n=ka+{\frac{k\left( k-1 \right)}{2}}$</p><p>从而得到：$2n=k(2a+k-1)$</p><p>设 $x=k$、$y=2a+k-1$，则 $xy=2n$ 。</p><p>**推条件：**由题意知，首项 $a&gt;0$ ，则 $2a=y-x+1&gt;0$，$y&gt;x-1$，即 $x\leqslant y$；由于首项 $a$ 为整数，且首项 $a$ 满足 $2a=y-x+1&gt;0$，即 $a=\frac{y-x+1}{2}$，即 $y-x+1$ 为偶数。</p><p>**推范围：**由于 $x\leqslant y$，且 $xy=2n$，得 $x\leqslant {\frac{2n}{x}}$，即 $x\leqslant \sqrt{2n}$。</p><p>**输出要求：**由于要先输出尽可能小的数，已知 $a$ 为首项，因此只要让 $a$ 由小往大遍历即可。由上面的等式可以得到 $2a = \frac{2n}{k}-(k+1)$，可见 $a$ 会随 $k$ 的增加而减少 ，且由于 $x=k$，因此只要让 $x$ 由大往小遍历即可。</p><h2 id="三、题解">三、题解</h2><p>不知道为什么二分的时间会更长</p><img src="https://s1.ax1x.com/2023/07/17/pCI4oi6.png" alt="image-20230716234258894" style="zoom:80%;"><blockquote><p><strong>ChatGPT是这样说的：</strong></p><p>首先，我们来看一下它们的时间复杂度：</p><ul><li>二分方法的代码：在平均情况下，二分查找算法的时间复杂度为O(logn)。由于在每次迭代中，我们将搜索范围减半，因此该代码的时间复杂度可以近似为O(logn)。</li><li>暴力枚举的代码：在该代码中，我们使用了一个循环来逐步增加序列的长度，直到找到满足条件的序列。因此，该代码的时间复杂度为O(n)。</li></ul><p>现在我们来解释为什么&quot;二分方法的代码&quot;的运行时间较长：</p><ol><li>二分方法的代码中使用了二分查找来寻找满足条件的序列的起始和结束位置。这需要多次进行二分查找操作，每次查找都需要将搜索范围减半。虽然二分查找的时间复杂度较低，但它在一次迭代中进行了多次查找。</li><li>每次二分查找中，我们还需要进行一些复杂的乘法和除法运算来计算中间位置的值。这些运算需要一定的时间。</li><li>此外，二分方法的代码还包含了一些其他的操作，如条件判断和循环控制。这些操作也会增加代码的运行时间。</li></ol><p>因此，相对于暴力枚举的代码，二分方法的代码需要进行更多的操作和计算，导致其运行时间更长。在特定情况下，例如当输入的n较大时，二分方法的代码的差距会更加明显。</p></blockquote><h4 id="方法一：暴力枚举-O-n-2">方法一：暴力枚举 $O(n^2)$</h4><p>没想到暴力也能过٩(๑&gt;◡&lt;๑)۶</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, j = i;<br>        <span class="hljs-keyword">while</span> (sum + j &lt; n) sum += j, j++;<br>        <span class="hljs-keyword">if</span> (sum + j == n) <br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt;= j; k++) <br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k); <br>            flag = <span class="hljs-literal">true</span>; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NONE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二：二分">方法二：二分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; a &lt;= n / <span class="hljs-number">2</span>; a++)<br>    &#123;<br>        <span class="hljs-type">int</span> l = a + <span class="hljs-number">1</span>, r = n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) <br>        &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-comment">// 在后续计算中使用乘法会导致超出int的范围, 因此选择使用long long类型</span><br>            <span class="hljs-keyword">if</span> ((a + mid) * (mid - a + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &gt;= n) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((a + l) * (l - a + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> == n) <br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = a; k &lt;= l; k++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k); <br>            flag = <span class="hljs-literal">true</span>; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NONE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法三：数学知识">方法三：数学知识</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span> * n); x &gt;= <span class="hljs-number">2</span>; x--)<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * n % x == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> y = <span class="hljs-number">2</span> * n / x;<br>            <span class="hljs-type">int</span> k = x;<br>            <span class="hljs-type">int</span> t = y - x + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = t / <span class="hljs-number">2</span>; i &lt; k; i++, j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, j);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NONE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>数学知识</tag>
      
      <tag>试除法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing3302. 表达式求值</title>
    <link href="/2023/07/12/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2023/07/12/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1>AcWing3302. 表达式求值</h1><blockquote><p><strong>原题链接：</strong><a href="https://www.acwing.com/problem/content/3305/">3302. 表达式求值 - AcWing题库</a></p></blockquote><h2 id="一、题目">一、题目</h2><p>给定一个表达式，其中运算符仅包含 <code>+,-,*,/</code>（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p><p><strong>注意：</strong></p><ul><li>数据保证给定的表达式合法。</li><li>题目保证符号 <code>-</code> 只作为减号出现，不会作为负号出现，例如，<code>-1+2</code>,<code>(2+2)*(-(1+1)+2)</code> 之类表达式均不会出现。</li><li>题目保证表达式中所有数字均为正整数。</li><li>题目保证表达式在中间计算过程以及结果中，均不超过 $2^{31}−1$。</li><li>题目中的整除是指向 00 取整，也就是说对于大于 00 的结果向下取整，例如 $5/3=1$，对于小于 $0$ 的结果向上取整，例如 $5/(1−4)=−1$。</li><li>C++和Java中的整除默认是向零取整；Python中的整除<code>//</code>默认向下取整，因此Python的<code>eval()</code>函数中的整除也是向下取整，在本题中不能直接使用。</li></ul><p><strong>输入格式</strong></p><p>共一行，为给定表达式。</p><p><strong>输出格式</strong></p><p>共一行，为表达式的结果。</p><p><strong>数据范围</strong></p><p>表达式的长度不超过 $10^5$。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs input">(2+2)*(1+1)<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">8<br></code></pre></td></tr></table></figure><h2 id="二、样例分析">二、样例分析</h2><p>题目中所给的表达式为<strong>中缀表达式</strong>，先将其转化为<strong>中缀表达式树</strong>（所有内部结点都是运算符、所有叶子结点都是数）：</p><img src="https://s1.ax1x.com/2023/07/16/pCInwKf.png" style="zoom:100%;"><p>中序遍历树得到的中缀表达式要加括号（保证运算符的优先级），即结果为 $(2+2)×(1+1)$ 而非 $2+2×1+1$ ；后序遍历树得到的后缀表达式不需要加括号，即结果为 $2\ 2+1\ 1+×$ 。</p><p>可以通过<strong>递归</strong>的方式求解：</p><img src="https://s1.ax1x.com/2023/07/16/pCInBqS.png" style="zoom:100%;"><p><strong>中序遍历+栈：</strong></p><img src="https://s1.ax1x.com/2023/07/16/pCInrVg.png" style="zoom:100%;"><h2 id="三、题解">三、题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span><span class="hljs-comment">// 哈希表</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>stack&lt;<span class="hljs-type">int</span>&gt; num;<span class="hljs-comment">// 存数字</span><br>stack&lt;<span class="hljs-type">char</span>&gt; op;<span class="hljs-comment">// 存运算符</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> b = num.<span class="hljs-built_in">top</span>(); num.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 取出第二个数字</span><br>    <span class="hljs-keyword">auto</span> a = num.<span class="hljs-built_in">top</span>(); num.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 取出第一个数字</span><br>    <span class="hljs-keyword">auto</span> c = op.<span class="hljs-built_in">top</span>(); op.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 取出运算符</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-comment">// 计算</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span>) x = a + b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>) x = a - b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;*&#x27;</span>) x = a * b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) x = a / b;<br>    num.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">// 将计算结果存入栈中</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; pr&#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>&#125;&#125;;<span class="hljs-comment">// 定义各个运算符的优先级, 数越大优先级越大</span><br>    string str;<br>    cin &gt;&gt; str;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> c = str[i];<span class="hljs-comment">// 存取当前字符</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))<span class="hljs-comment">// 如果当前字符是数字, 把当前的数字取出来</span><br>        &#123;<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[j]))<br>                x = x * <span class="hljs-number">10</span> + str[j++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            i = j - <span class="hljs-number">1</span>;<span class="hljs-comment">// 变化指针i的位置</span><br>            num.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">// 把数字放到栈里</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) op.<span class="hljs-built_in">push</span>(c);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-built_in">eval</span>();<span class="hljs-comment">// 把栈里面所有运算符从右往左操作一遍, 直到遇到 (</span><br>            op.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 弹出左括号</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 一般的运算符</span><br>        &#123;<br>            <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>() &amp;&amp; op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="hljs-built_in">top</span>()] &gt;= pr[c]) <span class="hljs-built_in">eval</span>();<span class="hljs-comment">// 运算符栈不为空, 且栈顶元素优先级高于当前元素, 循环操作高优先级运算符</span><br>            op.<span class="hljs-built_in">push</span>(c);<span class="hljs-comment">// 将当前运算符存入栈</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">eval</span>();<span class="hljs-comment">// 从右往左操作一遍运算符</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, num.<span class="hljs-built_in">top</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>表达式求值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列</title>
    <link href="/2023/07/09/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2023/07/09/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1>栈与队列：单调队列、单调栈</h1><blockquote><p>使用<strong>数组</strong>模拟</p></blockquote><img src="https://s1.ax1x.com/2023/07/16/pC5OlxP.png" style="zoom:80%;"><h2 id="1-栈">1. 栈</h2><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// tt表示栈顶下标</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[++tt] = x;<br><br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt--;<br><br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><br><span class="hljs-comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-队列">2. 队列</h2><h3 id="1-普通队列">1. 普通队列</h3><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[++tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh++;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-循环队列">2. 循环队列</h3><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// hh 表示队头，tt表示队尾的后一个位置</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[tt++] = x;<br><span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh++;<br><span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh != tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-单调栈">3. 单调栈</h2><blockquote><p>**常见题型：**给定一个序列，找到这个序列中每一个数左边离它最近的数的位置。</p></blockquote><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; <span class="hljs-built_in">check</span>(stk[tt], i)) tt -- ;<br>    stk[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-单调队列">4. 单调队列</h2><blockquote><p>**最经典的应用：**求滑动窗口中的最大值或最小值</p></blockquote><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check_out</span>(q[hh])) hh ++ ;  <span class="hljs-comment">// 判断队头是否滑出窗口</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check</span>(q[tt], i)) tt -- ;<br>    q[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
      <tag>单调栈</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表与邻接表</title>
    <link href="/2023/07/08/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    <url>/2023/07/08/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1>链表与邻接表：树与图的存储</h1><ul><li><p>使用<strong>数组</strong>模拟（静态链表）</p></li><li><p>使用<strong>指针</strong>+<strong>结构体</strong>模拟（动态链表、在笔试题中一般不会用）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    Node *next;<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(); <span class="hljs-comment">// 非常慢</span><br></code></pre></td></tr></table></figure><h2 id="1-使用数组模拟单链表">1. 使用数组模拟单链表</h2><p>在算法题中，使用最多的单链表是邻接表（n个链表）</p><h3 id="1-1-单链表与邻接表">1.1 单链表与邻接表</h3><p>**邻接表的用途：**存储数与图</p><p>在单链表中，用<code>e[ ]</code>表示该结点的值，用<code>ne[ ]</code>表示该结点的下一结点的编号。</p><img src="https://s1.ax1x.com/2023/07/16/pC5OQ2t.png" style="zoom:80%;"><h3 id="1-2-单链表的优缺点（单链表是只往后看的）">1.2 单链表的优缺点（单链表是只往后看的）</h3><p>**优点：**单链表可以用 $O(1)$ 的时间找到下一个结点的位置</p><p>**缺点：**单链表不能用 $O(1)$ 的时间找到上一个结点的位置（只能从头开始遍历）</p><h3 id="1-3-模板">1.3 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx++;<br>&#125;<br><br><span class="hljs-comment">// 在链表第k个结点后面插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = ne[k], ne[k] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = ne[head];<br>&#125;<br><br><span class="hljs-comment">// 将下标是k的点后面的点删掉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k] = ne[ne[k]];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-使用数组模拟双链表">2. 使用数组模拟双链表</h2><p>**双链表的用途：**优化某些问题</p><ul><li>双链表与单链表的区别在于：单链表只有一个方向，双链表是双向的</li></ul><h3 id="模板"><strong>模板</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//0是左端点，1是右端点</span><br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 在节点a的右边插入一个数x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    l[idx] = a, r[idx] = r[a];<br>    l[r[a]] = idx, r[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 删除节点a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    l[r[a]] = l[a];<br>    r[l[a]] = r[a];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单链表</tag>
      
      <tag>双链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间合并</title>
    <link href="/2023/07/04/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <url>/2023/07/04/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1>区间合并</h1><p>**应用场景：**将 $n$ 个区间中，所有有交集的区间合并（假设两个区间只有端点相交的，那么他们也是可以合并的）。</p><img src="https://s1.ax1x.com/2023/07/15/pC5Qrvt.png" style="zoom:80%;"><p><strong>算法步骤：</strong></p><ol><li><p>按区间的左端点排序</p></li><li><p>扫描整个区间，把所有有交集的区间合并</p></li></ol><h2 id="模板">模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//区间按照做端点排序</span><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<span class="hljs-comment">// 定义+无穷和-无穷</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区间合并</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散化</title>
    <link href="/2023/07/04/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <url>/2023/07/04/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1>离散化</h1><blockquote><p>特指整数的离散化、保序的离散化</p></blockquote><p>**序列特点：**值域较大（$0$ ~ $10^9$）、个数较少（可能只有$10^5$个数）</p><p>有些题目可能要以这些序列的值为下标来做，因此需要把序列映射到从 $0$ 开始的连续的自然数。</p><img src="https://s1.ax1x.com/2023/07/15/pC5QM4J.png" style="zoom:80%;"><p><strong>离散化中常见的两个问题：</strong></p><ol><li><code>a[]</code>中可能有重复元素  -&gt; 去重</li><li>如何计算<code>x</code>离散化后的值 -&gt; 二分查找</li></ol><h2 id="模板">模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2023/07/04/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2023/07/04/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1>位运算</h1><p>常用的两种位运算的操作：求 $n$ 的第 $k$ 位数字和 $n$ 的最后一位</p><h2 id="1-n的二进制表示中第k位">1. n的二进制表示中第k位</h2><p><strong>思路：</strong></p><ol><li>先把第 $k$ 位移到最后一位，即<code>n &gt;&gt; k</code></li><li>看一下最低位是几，<code>x &amp; 1</code></li></ol><p>结合①和②，得到公式：<code>n &gt;&gt; k &amp; 1</code></p><blockquote><p>位移运算不会改变原数据的值，即<code>n &gt;&gt; k</code>前后<code>n</code>的值不变</p></blockquote><h2 id="2-n的二进制表示中最后一位">2. n的二进制表示中最后一位</h2><p><code>lowbit()</code>是树状数组的基本操作，<code>lowbit(x)</code>的作用是返回<code>x</code>的最后一位<code>1</code>。例如：如果二进制数<code>x = 1010</code>，则<code>lowbit(x)</code>返回的是<code>10</code>，即十进制数<code>2</code>；如果二进制数<code>x = 101000</code>，则<code>lowbit(x)</code>返回的是<code>1000</code>，即十进制数<code>8</code>。</p><p><strong>实现：</strong><code>lowbit(x) = x &amp; -x</code>。其中，<code>-x</code>是<code>x</code>的补码，即<code>x</code>取反加一</p><p>**应用：**统计<code>x</code>的二进制表示中<code>1</code>的个数。每次把最后一位<code>1</code>减掉，当<code>x</code>的值为<code>0</code>时停止，统计循环次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求n的第k位数字: </span><br>n &gt;&gt; k &amp; <span class="hljs-number">1</span><br><span class="hljs-comment">// 返回n的最后一位1：</span><br><span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制的第k位</tag>
      
      <tag>lowbit( )</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针算法</title>
    <link href="/2023/07/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <url>/2023/07/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1>双指针算法</h1><ul><li><p><strong>第一类：<strong>指向的是</strong>两个序列</strong>，例如：归并排序中的双指针</p></li><li><p><strong>第二类：<strong>指向的是</strong>一个序列</strong>（常见），例如：快速排序的双指针</p></li></ul><h2 id="1-核心思想">1. 核心思想</h2><p>将下面的朴素算法的时间复杂度优化到 $O(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        <span class="hljs-comment">// 操作</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么双指针算法的时间复杂度是 $O(n)$ ?</strong></p><p>双指针算法的时间复杂度为 $O(n)$ 的原因是，它通常在一个循环中使用两个指针进行迭代，而这两个指针相对于输入规模 $n$ 的数量级是线性的。</p><p>在双指针算法中，指针通常从输入序列的两端开始，然后向中间移动，根据特定的条件调整指针的位置。算法的终止条件可能是两个指针相遇或到达特定位置。</p><p>由于每次迭代中，指针的移动都是以固定的步长进行的，而且指针从两个方向同时移动，因此整个算法的执行时间与输入规模 $n$ 成线性关系。换句话说，算法的运行时间随着输入规模的增加而线性增长。</p><p>需要注意的是，虽然双指针算法的时间复杂度通常是 $O(n)$，但也可以有特殊情况下的变体，其时间复杂度可能是 $O(n^2)$ 或其他不同的复杂度。这取决于算法的具体实现和问题的特定要求。但是，一般而言，双指针算法的时间复杂度是线性的，即 $O(n)$。</p></blockquote><h2 id="2-例子">2. 例子</h2><p><strong>题目要求：</strong></p><p>输入一个字符串，其中包含多个单词，每个单词用空格隔开，输出每个单词。（假定字符串开始时没有空格，且每个单词之间只有一个空格）</p><p><strong>分析：</strong></p><img src="https://s1.ax1x.com/2023/07/15/pC5M5nK.png" style="zoom:80%;"><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">1000</span>];<br>    <span class="hljs-built_in">gets</span>(str);<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; str[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++;<br>        <span class="hljs-comment">// 这道题的具体逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; k++) cout &lt;&lt; str[k];<br>        cout &lt;&lt; endl;<br>        i = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-模板">3. 模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j++ ;<br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br><span class="hljs-comment">// 常见问题分类：</span><br>    <span class="hljs-comment">// (1) 对于一个序列，用两个指针维护一段区间</span><br>    <span class="hljs-comment">// (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></code></pre></td></tr></table></figure><p><strong>总结（双指针算法的实现思路）</strong></p><ol><li>写出题目对应的暴力解法（时间复杂度为 $O(n^2)$），寻找两个循环索引 $i、j$ 之间的单调关系</li><li>如果有单调关系的话，利用其单调关系，把状态数量由 $n^2$ 变成 $n$，从而把时间复杂度由 $O(n^2)$ 变成 $O(n)$</li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2023/07/02/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2023/07/02/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1>前缀和与差分</h1><p><strong>差分：</strong>$a_1$、$a_2$、$a_3$、……、$a_n$ （下标从 $1$ 开始）</p><p><strong>前缀和：</strong>$S_1$、$S_2$、$S_3$、……、$S_n$     其中，$S_i=a_1+a_2+a_3+…+a_i$ （下标从 $1$ 开始，定义 $S_0=0$）</p><h2 id="1-前缀和">1. 前缀和</h2><h4 id="1-涉及到的两个问题">1. 涉及到的两个问题</h4><ol><li><p>如何求 $S_i$ ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一维前缀和的初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<span class="hljs-comment">// 前缀和的初始化</span><br><span class="hljs-comment">// 二维前缀和的初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        s[i][j] = a[i][j] + s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li><li><p>前缀和数组 $S_i$ 的作用：快速求出原数组中的一段数的和。</p><blockquote><p>**前缀和数组作用的例子：**假设题目要求求出数组中<code>[l, r]</code>的数的和（区间和的计算）</p><ul><li>如果没有前缀和数组，则需循环一遍求解，此时时间复杂度为 $O(n)$</li><li>如果有前缀和数组，则可直接计算得出 $S_r-S_{l-1}$，此时时间复杂度为 $O(1)$</li></ul></blockquote></li></ol><h4 id="2-为什么前缀和的下标从1开始">2. 为什么前缀和的下标从1开始</h4><p>**主要是处理边界问题：**当需要求数组<code>[1, t]</code>的数的和的时候，可以直接通过 $S_t-S_0$，不用考虑边界问题。同时，这也是把 $S_0$ 定义为 $0$ 的原因。虽然该问题可以直接以 $S_t$ 为答案，但是为了统一计算公式，选择这种计算方法。</p><h3 id="1-1-一维前缀和">1.1 一维前缀和</h3><p>作用：<strong>快速求出某一区间的和</strong></p><p><strong>原数组：</strong>$a_i$</p><p><strong>前缀和数组：</strong>$S_i$</p><p><strong>区间和计算公式：</strong>$[l,\ r]=S_r-S_{l-1}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="1-2-二维前缀和">1.2 二维前缀和</h3><p>与一维前缀和类似，二维前缀和是为了<strong>快速求出某一子矩阵的和</strong></p><p><strong>原数组：</strong>$a_{ij}$</p><p><strong>前缀和数组：</strong>$S_{ij}$</p><p><strong>子矩阵和计算公式：</strong><br>$$<br>\left[ \begin{matrix}<br>\left( x_1, y_1 \right)&amp;\left( x_1, y_2 \right)\<br>\left( x_2, y_1 \right)&amp;\left( x_2, y_2 \right)\<br>\end{matrix} \right] =S_{x_2y_2}-S_{x_1-1 y_2}-S_{x_2,,y_1-1}+S_{x_1-1 y_1-1}<br>$$<br><img src="https://s1.ax1x.com/2023/07/15/pC5Mapn.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">S[i, j] =  <span class="hljs-comment">// 第i行j列格子左上部分所有元素的和</span><br><span class="hljs-comment">// 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/07/15/pC5Mw60.png" style="zoom:80%;"><h2 id="2-差分">2. 差分</h2><h4 id="1-差分的作用">1. 差分的作用</h4><p>对于数组 $a_i\ (i=1,2,3,…,n)$，其前缀和为 $s_i\ (i = 1,2,3,…,n)$。$a_i$ 为 $s_i$ 的差分，满足 $a_i\ = s_i \ - \ s_{i-1}$，即：<br>$$<br>a_1 = s_1\<br>a_2 = s_2-s_1\<br>a_3 = s_3-s_2\<br>a_4 = s_4-s_3\<br>……\<br>a_n = s_n-s_{n-1}<br>$$<br>**作用：**对于前缀和数组 $s_i$ ，如果需要使其从第 $l$ 项开始到第 $r$ 项每项都增加一个常数 $C$ 。如果直接对前缀和数组 $s_i$ 操作的话，即对 $s_i\ (i = l,l+1,…,r)$ 每一项都增加一个常数 $C$，程序的时间复杂度为 $O(n)$；如果对差分数组 $a_i$ 操作的话，即使 $a_l + C$ 、$a_{r+1} - C$，程序的时间复杂度为 $O(1)$。</p><h3 id="2-1-一维差分">2.1 一维差分</h3><p>**作用：**给一维数组的一段加上一个值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br></code></pre></td></tr></table></figure><blockquote><p><strong>过程：</strong></p><ol><li><p>定义前缀和数组，并输入初值（给 $s_i$ 赋初值）</p></li><li><p>根据前缀和数组的值，给差分数组赋初值（给 $a_i$ 赋值）</p><p>对于差分数组中的第 $i$ 个元素，采用插入的方式：对于区间<code>[i,i]</code>插入<code>s[i]</code>，即<code>a[i] + s[i]</code>、<code>a[i+1] - s[i]</code></p></li><li><p>根据差分数组，求出其前缀和即可</p></li></ol></blockquote><h3 id="2-2-二维差分">2.2 二维差分</h3><p>**作用：**给二维数组数组的一个子矩阵加上一个值</p><img src="https://s1.ax1x.com/2023/07/15/pC5Ms7F.png" style="zoom:80%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></td></tr></table></figure><blockquote><p>过程同一维差分，只不过计算差分数组的方式不同</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度</title>
    <link href="/2023/07/01/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/2023/07/01/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1>高精度</h1><blockquote><p><code>A</code>和<code>B</code>的位数约为$10^6$，即<code>len(A)</code>和<code>len(B)</code>的结果为$10^6$</p><p><code>a</code>的数值小于等于$10^9$，即<code>a&lt;=10^9</code></p></blockquote><h2 id="1-大整数是如何表示的">1. 大整数是如何表示的</h2><p>用<code>int</code>肯定是不行的，一般把大整数存储在数组里，并且要存储的数的最低位要放在数组索引为<code>0</code>的位置，即倒序存储。</p><blockquote><p><strong>大整数存储要倒序的原因：</strong></p><p>在对大整数做运算时，很可能出现进位的情况。当正序存储且需要进位时，就需要把数组中的所有元素后移一位，腾出最高位的空间。但是这会大大提高程序运行的时间复杂度，因此选择使用倒序存储。</p></blockquote><p>大整数的运算是一个模拟人工加法/减法/乘法/除法的过程。</p><blockquote><p>通常以字符串的形式读入大整数，然后通过<code>for</code>循环遍历字符串中的每个元素，存储到<code>vector&lt;int&gt;</code>中。注意，在存储的时候，要将字符串中的字符元素转化为整型元素，即<code>a[i] - '\0'</code>.</p></blockquote><h2 id="2-两个比较大的整数相加A-B">2. 两个比较大的整数相加<code>A+B</code></h2><h3 id="2-1-实现原理">2.1 实现原理</h3><img src="https://s1.ax1x.com/2023/07/14/pC4xFN4.png" style="zoom:100%;"><p><strong>串行进位加法器</strong>：从最低位开始计算，每一位的运算都是$A_i+B_i+t$，其中$A_i$是被加数的第$i$位、$B_i$是加数的第$i$位、$t$是上一位的进位。最初状态时，$t$被赋初值$0$，相当于向最低位的进位为$0$。</p><h3 id="2-2-代码模板">2.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span><span class="hljs-comment">// 接收结果时, 可以使用auto类型</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    vector&lt;int&gt; C;</span><br><span class="hljs-comment">    int t = 0;</span><br><span class="hljs-comment">    for (int i = 0; i &lt; A.size() || i &lt; B.size(); i ++ )</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        if (i &lt; A.size()) t += A[i];</span><br><span class="hljs-comment">        if (i &lt; B.size()) t += B[i];</span><br><span class="hljs-comment">        C.push_back(t % 10);</span><br><span class="hljs-comment">        t /= 10;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    if (t) C.push_back(t);</span><br><span class="hljs-comment">    return C;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="3-两个比较大的整数相减A-B">3. 两个比较大的整数相减<code>A-B</code></h2><h3 id="3-1-实现原理">3.1 实现原理</h3><img src="https://s1.ax1x.com/2023/07/14/pC4xk4J.png" style="zoom:100%;"><p><strong>(1) 两步实现：</strong></p><ol><li><p>判断<code>A</code>和<code>B</code>的大小。如果<code>A&gt;=B</code>，直接算<code>A-B</code>；如果<code>A&lt;B</code>，计算<code>B-A</code>后加上负号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断是否有 A &gt;= B</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span>(A[i] != B[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<span class="hljs-comment">// A &gt; B</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// A = B</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算<code>A-B</code></p></li></ol><p>**(2) 对于每一位的计算：**需要计算$A_i-B_i-t$，其中$A_i$是被减数的第$i$位、$B_i$是减数的第$i$位、$t$是上一位借位。最初状态时，$t$被赋初值$0$，相当于向最低位的借位为$0$。如果其结果<code>&gt;=0</code>，则直接为该位的计算结果；如果其结果<code>&lt;0</code>，则说明该位不够减，应该向上一位借位，从而在结果上<code>+10</code>。$t$根据借位与否，决定其之后的值是1还是0。</p><h3 id="3-2-代码模板">3.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 去掉前导0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-一个大整数乘一个小整数A-a">4. 一个大整数乘一个小整数<code>A*a</code></h2><h3 id="4-1-实现原理">4.1 实现原理</h3><p>对于每一位的计算：分别计算当前位于乘数的乘积。计算 $(A_i*b+t)%10$ 作为当前位的计算结果，$(A_i+b+t)/10$ 作为当前位的进位，并赋值给 $t$。其中，$A$ 是乘数（大整数）、$b$ 是小整数、$t$ 是上一位的进位。</p><h3 id="4-2-代码模板">4.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<span class="hljs-comment">// 当前位的计算结果</span><br>        t /= <span class="hljs-number">10</span>;<span class="hljs-comment">// 进位</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-一个大整数除以一个小整数A-b">5. 一个大整数除以一个小整数<code>A/b</code></h2><h3 id="5-1-实现原理">5.1 实现原理</h3><p>模拟<strong>人工除法</strong>的过程：定义被除数为 $A$（大整数）、除数为 $b$（小整数）、余数 $r$（小整数），初始时 $r$ 的值定义的 $0$。计算每一位的时候，$(r<em>10+A_i)/b$ 作为当前位的商，$(r</em>10+A_i)%b$ 作为当前位的余数。</p><p>计算结束后，由于计算结果不满足倒序存储，因此需要调用<code>reverse(C.begin(), C.end())</code>反转存储结果，使结果满足倒序存储。</p><h3 id="5-2-代码模板">5.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度加法</tag>
      
      <tag>高精度减法</tag>
      
      <tag>高精度乘法</tag>
      
      <tag>高精度除法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2023/07/01/%E4%BA%8C%E5%88%86/"/>
    <url>/2023/07/01/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1>二分</h1><p>二分的本质不是单调性。有单调性的题目一定可以二分，可以二分的题目不一定必须有单调性。</p><h2 id="1-整数二分">1. 整数二分</h2><img src="https://s1.ax1x.com/2023/07/14/pC4vynK.png" style="zoom:80%;"><h3 id="1-1-主要思想">1.1 主要思想</h3><p>在一个区间内部，使用二分的方法得到答案。每次选择答案所在的区间进行二分，且每次都能保证区间内有答案。对于有解的问题，二分得到的是正确答案；对于无解的题目，二分得到的是答案应该存在的位置。</p><h3 id="1-2-整数二分的实现过程">1.2 整数二分的实现过程</h3><ol><li>找一个中间值，即<code>mid = (l + r) / 2</code></li><li>（假设判断的是红色的性质）每次判断一下中间值是否满足性质，即<code>if(check(mid))</code><ul><li>情况一：<code>true</code><ul><li>说明<code>mid</code>满足该性质，因此<code>ans</code>所在区间为<code>[mid, r]</code></li><li>更新方式：<code>l = mid</code></li></ul></li><li>情况二：<code>false</code><ul><li>说明<code>mid</code>不满足该性质，因此<code>ans</code>所在区间为<code>[l, mid - 1]</code></li><li>更新方式：<code>r = mid - 1</code></li></ul></li></ul></li><li>（假设判断的是绿色的性质）每次判断一下中间值是否满足性质，即<code>if(check(mid))</code><ul><li>情况一：<code>true</code><ul><li>说明<code>mid</code>满足该性质，因此<code>ans</code>所在区间为<code>[l, mid]</code></li><li>更新方式：<code>r = mid</code></li></ul></li><li>情况二：<code>false</code><ul><li>说明<code>mid</code>不满足该性质，因此<code>ans</code>所在区间为<code>[mid + 1, r]</code></li><li>更新方式：<code>l = mid + 1</code></li></ul></li></ul></li></ol><blockquote><p><strong>中间值“是否+1”的问题</strong></p><p>如果<code>mid = (l + r) / 2</code>，当<code>l = r - 1</code>时，求得<code>mid</code>的值为<code>l</code>，倘若此时<code>check()</code>正好取得<code>true</code>，则会执行<code>l = mid</code>，即<code>l</code>更新后的值还是<code>l</code>，就会陷入死循环状态。</p></blockquote><h3 id="1-3-模板">1.3 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-浮点数二分">2. 浮点数二分</h2><h3 id="2-1-浮点数二分的实现过程">2.1 浮点数二分的实现过程</h3><img src="https://s1.ax1x.com/2023/07/14/pC4vrX6.png" style="zoom:80%;"><p>由于浮点数除法的结果仍然是浮点数，是保留精度的，其与整数除法的整除存在一定的差异。因此，浮点数二分不用考虑<strong>边界问题</strong>，其能够准确的把两个区间分为两部分。</p><h3 id="2-2-模板">2.2 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<span class="hljs-comment">// 注意是大-小, 或者直接用abs()函数取绝对值</span><br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>经验</strong>：如果题目要求保留4位小数，则<code>r-l</code>应该小于<code>1e-6</code>；如果题目要求保留5位小数，则<code>r-l</code>应该小于<code>1e-7</code>；如果题目要求保留6位小数，则<code>r-l</code>应该小于<code>1e-8</code>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整数二分</tag>
      
      <tag>浮点数二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2023/06/29/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/06/29/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1>归并排序</h1><h2 id="1-主要思想">1. 主要思想</h2><p>归并排序算法的主要思想：<strong>分治</strong></p><h2 id="2-归并排序的步骤">2. 归并排序的步骤</h2><ol><li><p>确定分界点</p><ul><li><p>以数组的中间位置为分界点，分为左右两部分。</p></li><li><p><code>mid = (l + r) / 2</code></p></li></ul></li><li><p>递归排序左右两部分</p><ul><li>递归左右两部分，对最小的单位进行排序</li></ul></li><li><p>归并——合二为一**（重难点）**</p><ul><li>把两个有序的数组合并为一个有序的数组</li></ul></li></ol><ul><li><strong>时空复杂度：</strong><ul><li>时间复杂度：$O(nlog_2n)$</li><li>空间复杂度：$O(n)$</li></ul></li></ul><h2 id="3-实现过程（双指针算法）">3. 实现过程（双指针算法）</h2><img src="https://s1.ax1x.com/2023/07/14/pC4vPfA.png"><blockquote><p>图片摘自：<a href="http://t.csdn.cn/RNb0o">http://t.csdn.cn/RNb0o</a></p></blockquote><h2 id="4-模板">4. 模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前区间是否只有一个数或者没有数</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-comment">// 排序当前数组</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++] = q[j++];<br>    <span class="hljs-comment">// 处理某数组的元素全部排序完成，另一个数组中包含元素的情况</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];<br>    <span class="hljs-comment">// 把临时数组中排好序的内容转移到要排序的数组</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2023/06/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/06/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1>快速排序</h1><h2 id="1-主要思想">1.  主要思想</h2><p>快速排序算法的主要思想：<strong>分治</strong></p><h2 id="2-快速排序的步骤">2. 快速排序的步骤</h2><ol><li>确定分界点<code>x</code><ul><li>确定一个分界点，用于将数组划分为两个子数组</li><li>常用方式：取边界（<code>q[l]</code>或<code>q[r]</code>）、取中间值（<code>q[(l+r)/2]</code>）、取区间内随机一个数</li></ul></li><li>调整区间**（重难点）**<ul><li>根据分界点，把区间分为两部分，使得左边区间的数都<code>&lt;=x</code>，右边区间的数都<code>&gt;=x</code></li></ul></li><li>递归处理左右两段区间</li></ol><img src="https://s1.ax1x.com/2023/07/14/pC4LFqe.png"><h2 id="3-如何调整区间">3. 如何调整区间</h2><h3 id="方法一：暴力法（思想简单、占用额外空间）">方法一：暴力法（思想简单、占用额外空间）</h3><ul><li><strong>基本思想：</strong><ul><li><p>首先，开两个额外的数组<code>a[]</code>、<code>b[]</code>。</p></li><li><p>然后，扫描<code>q[l] ~ q[r]</code>的每一个数。如果<code>q[i]&lt;=x</code>，则把其插入到数组<code>a[]</code>中；如果<code>q[i]&gt;x</code>，则把其插入到数组<code>b[]</code>中。</p></li><li><p>最后，先遍历数组<code>a[]</code>，再遍历数组<code>b[]</code>，把数组中的数依次存储到数组<code>q[]</code>中。</p></li></ul></li><li><strong>时空复杂度：</strong><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul></li></ul><h3 id="方法二：双指针法（优美而简洁）">方法二：双指针法（优美而简洁）</h3><blockquote><p>**要点：**在任何时刻，<code>i</code>指针左边所有的数都一定<code>&lt;=x</code>，<code>j</code>指针右边的数都一定<code>&gt;=x</code>。</p><p>**原因：**当<code>i</code>指针在遍历时，如果当前数满足<code>&lt;x</code>的条件时，则<code>i</code>会指向下一个数；如果当前数不满足<code>&lt;x</code>的条件时，<code>i</code>指针会等待<code>j</code>指针找到一个<code>&gt;=x</code>的数与之交换，从而使得当前数也满足<code>&lt;=x</code>的条件。最终，<code>i</code>指针左侧所有的数都一定<code>&lt;=x</code>。对于<code>j</code>指针，同理。</p></blockquote><ul><li><p><strong>基本思想：</strong></p><ul><li><p>定义两个指针<code>i</code>和<code>j</code>，分别指向要排序的数组<code>q</code>的两端</p><img src="https://s1.ax1x.com/2023/07/14/pC4LirD.png" alt="pC4LirD.png"></li><li><p>两个指针分别往中间走，即<code>i++</code>和<code>j--</code>。</p><ul><li><p>首先，移动<code>i</code>指针。当<code>i</code>指向的值满足<code>q[i]&lt;x</code>时，<code>i</code>做自增运算，即<code>i++</code>；否则，<code>i</code>指针停止移动。</p></li><li><p>然后，移动<code>j</code>指针。当<code>j</code>指向的值满足<code>q[j]&gt;x</code>时，<code>j</code>做自减运算，即<code>j--</code>；否则，<code>j</code>指针停止移动。</p><img src="https://s1.ax1x.com/2023/07/14/pC4LPKO.png" alt="pC4LPKO.png"></li></ul></li><li><p>做完上述指针移动操作后，<code>i</code>指针左边所有的值都满足<code>q[]&lt;x</code>，<code>j</code>指针右边所有的值都满足<code>q[]&gt;x</code>，但此时<code>q[i]&gt;=x</code>且<code>q[j]&lt;=x</code>。为满足要求（调整区间），需要通过交换<code>i</code>和<code>j</code>指向的值，使得<code>i</code>指向的值满足<code>q[i]&lt;=x</code>、<code>j</code>指向的值满足<code>q[j]&gt;=x</code>，从而使程序能够继续运行。</p><img src="https://s1.ax1x.com/2023/07/14/pC4LmGt.png" alt="pC4LmGt.png"></li><li><p>当<code>i&gt;j</code>时，说明已经得到了两端调整后的区间（此时，<code>i</code>指针左边的值都满足小于等于x，<code>j</code>指针右边的值都满足大于等于x）</p><img src="https://s1.ax1x.com/2023/07/14/pC4L9xK.png" alt="pC4L9xK.png"></li></ul></li><li><p><strong>时空复杂度：</strong></p></li><li><p>时间复杂度：$O(nlog_2n)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><h2 id="4-模板">4. 模板</h2><h3 id="1-模板">(1) 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 模板1☆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前要排序的子数组中的元素个数是否&lt;=1</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 调整区间</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<span class="hljs-comment">// 这里尽量用 j</span><br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-comment">// 模板2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前要排序的子数组中的元素个数是否&lt;=1</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 调整区间</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-关于边界问题">(2) 关于边界问题</h3><p><strong>正确代码1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<span class="hljs-comment">// 或者x = q[(l+r)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/07/14/pC4LAVH.png"><p><strong>错误代码1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[r];<span class="hljs-comment">// 或者x = q[(l+r)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/07/14/pC4LEad.png"><p><strong>正确代码2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[r];<span class="hljs-comment">// 或者x = q[(l+r+1)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/07/14/pC4LVIA.png"><p><strong>错误代码2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<span class="hljs-comment">// 或者x = q[(l+r+1)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/07/14/pC4LePI.png">]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
