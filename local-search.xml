<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>表达式求值</title>
    <link href="/2023/07/12/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2023/07/12/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="表达式求值">表达式求值</h1><blockquote><p><strong>原题链接：</strong><a href="https://www.acwing.com/problem/content/3305/">3302. 表达式求值 - AcWing题库</a></p></blockquote><h2 id="一题目">一、题目</h2><p>给定一个表达式，其中运算符仅包含 <code>+,-,*,/</code>（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p><p><strong>注意：</strong></p><ul><li>数据保证给定的表达式合法。</li><li>题目保证符号 <code>-</code> 只作为减号出现，不会作为负号出现，例如，<code>-1+2</code>,<code>(2+2)*(-(1+1)+2)</code> 之类表达式均不会出现。</li><li>题目保证表达式中所有数字均为正整数。</li><li>题目保证表达式在中间计算过程以及结果中，均不超过 <span class="math inline">\(2^{31}−1\)</span>。</li><li>题目中的整除是指向 00 取整，也就是说对于大于 00 的结果向下取整，例如 <span class="math inline">\(5/3=1\)</span>，对于小于 <span class="math inline">\(0\)</span> 的结果向上取整，例如 <span class="math inline">\(5/(1−4)=−1\)</span>。</li><li>C++和Java中的整除默认是向零取整；Python中的整除<code>//</code>默认向下取整，因此Python的<code>eval()</code>函数中的整除也是向下取整，在本题中不能直接使用。</li></ul><p><strong>输入格式</strong></p><p>共一行，为给定表达式。</p><p><strong>输出格式</strong></p><p>共一行，为表达式的结果。</p><p><strong>数据范围</strong></p><p>表达式的长度不超过 <span class="math inline">\(10^5\)</span>。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs input">(2+2)*(1+1)<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">8<br></code></pre></td></tr></table></figure><h2 id="二分析">二、分析</h2><h2 id="三题解">三、题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>stack&lt;<span class="hljs-type">int</span>&gt; num;<br>stack&lt;<span class="hljs-type">char</span>&gt; op;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> b = num.<span class="hljs-built_in">top</span>(); num.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">auto</span> a = num.<span class="hljs-built_in">top</span>(); num.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">auto</span> c = op.<span class="hljs-built_in">top</span>(); op.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span>) x = a + b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>) x = a - b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;*&#x27;</span>) x = a * b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) x = a / b;<br>    num.<span class="hljs-built_in">push</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; pr&#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>&#125;&#125;;<br>    string str;<br>    cin &gt;&gt; str;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> c = str[i];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))<br>        &#123;<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[j]))<br>                x = x * <span class="hljs-number">10</span> + str[j++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            i = j - <span class="hljs-number">1</span>;<br>            num.<span class="hljs-built_in">push</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) op.<span class="hljs-built_in">push</span>(c);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-built_in">eval</span>();<br>            op.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>() &amp;&amp; op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="hljs-built_in">top</span>()] &gt;= pr[c]) <span class="hljs-built_in">eval</span>();<br>            op.<span class="hljs-built_in">push</span>(c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">eval</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, num.<span class="hljs-built_in">top</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>表达式求值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列</title>
    <link href="/2023/07/09/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2023/07/09/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈与队列单调队列单调栈">栈与队列：单调队列、单调栈</h1><blockquote><p>使用<strong>数组</strong>模拟</p></blockquote><p><img src="https://s1.ax1x.com/2023/07/16/pC5OlxP.png" style="zoom:80%;"></p><h2 id="栈">1. 栈</h2><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// tt表示栈顶下标</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[++tt] = x;<br><br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt--;<br><br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><br><span class="hljs-comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列">2. 队列</h2><h3 id="普通队列">1. 普通队列</h3><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[++tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh++;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环队列">2. 循环队列</h3><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// hh 表示队头，tt表示队尾的后一个位置</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[tt++] = x;<br><span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh++;<br><span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh != tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调栈">3. 单调栈</h2><blockquote><p><strong>常见题型：</strong>给定一个序列，找到这个序列中每一个数左边离它最近的数的位置。</p></blockquote><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; <span class="hljs-built_in">check</span>(stk[tt], i)) tt -- ;<br>    stk[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列">4. 单调队列</h2><blockquote><p><strong>最经典的应用：</strong>求滑动窗口中的最大值或最小值</p></blockquote><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check_out</span>(q[hh])) hh ++ ;  <span class="hljs-comment">// 判断队头是否滑出窗口</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check</span>(q[tt], i)) tt -- ;<br>    q[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
      <tag>单调栈</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表与邻接表</title>
    <link href="/2023/07/08/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    <url>/2023/07/08/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表与邻接表树与图的存储">链表与邻接表：树与图的存储</h1><ul><li><p>使用<strong>数组</strong>模拟（静态链表）</p></li><li><p>使用<strong>指针</strong>+<strong>结构体</strong>模拟（动态链表、在笔试题中一般不会用）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    Node *next;<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(); <span class="hljs-comment">// 非常慢</span><br></code></pre></td></tr></table></figure><h2 id="使用数组模拟单链表">1. 使用数组模拟单链表</h2><p>在算法题中，使用最多的单链表是邻接表（n个链表）</p><h3 id="单链表与邻接表">1.1 单链表与邻接表</h3><p><strong>邻接表的用途：</strong>存储数与图</p><p>在单链表中，用<code>e[ ]</code>表示该结点的值，用<code>ne[ ]</code>表示该结点的下一结点的编号。</p><p><img src="https://s1.ax1x.com/2023/07/16/pC5OQ2t.png" style="zoom:80%;"></p><h3 id="单链表的优缺点单链表是只往后看的">1.2 单链表的优缺点（单链表是只往后看的）</h3><p><strong>优点：</strong>单链表可以用 <span class="math inline">\(O(1)\)</span> 的时间找到下一个结点的位置</p><p><strong>缺点：</strong>单链表不能用 <span class="math inline">\(O(1)\)</span> 的时间找到上一个结点的位置（只能从头开始遍历）</p><h3 id="模板">1.3 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx++;<br>&#125;<br><br><span class="hljs-comment">// 在链表第k个结点后面插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = ne[k], ne[k] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = ne[head];<br>&#125;<br><br><span class="hljs-comment">// 将下标是k的点后面的点删掉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k] = ne[ne[k]];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用数组模拟双链表">2. 使用数组模拟双链表</h2><p><strong>双链表的用途：</strong>优化某些问题</p><ul><li>双链表与单链表的区别在于：单链表只有一个方向，双链表是双向的</li></ul><h3 id="模板-1"><strong>模板</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//0是左端点，1是右端点</span><br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 在节点a的右边插入一个数x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    l[idx] = a, r[idx] = r[a];<br>    l[r[a]] = idx, r[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 删除节点a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    l[r[a]] = l[a];<br>    r[l[a]] = r[a];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单链表</tag>
      
      <tag>双链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间合并</title>
    <link href="/2023/07/04/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <url>/2023/07/04/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="区间合并">区间合并</h1><p><strong>应用场景：</strong>将 <span class="math inline">\(n\)</span> 个区间中，所有有交集的区间合并（假设两个区间只有端点相交的，那么他们也是可以合并的）。</p><p><img src="https://s1.ax1x.com/2023/07/15/pC5Qrvt.png" style="zoom:80%;"></p><p><strong>算法步骤：</strong></p><ol type="1"><li><p>按区间的左端点排序</p></li><li><p>扫描整个区间，把所有有交集的区间合并</p></li></ol><h2 id="模板">模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//区间按照做端点排序</span><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<span class="hljs-comment">// 定义+无穷和-无穷</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区间合并</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散化</title>
    <link href="/2023/07/04/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <url>/2023/07/04/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="离散化">离散化</h1><blockquote><p>特指整数的离散化、保序的离散化</p></blockquote><p><strong>序列特点：</strong>值域较大（<span class="math inline">\(0\)</span> ~ <span class="math inline">\(10^9\)</span>）、个数较少（可能只有<span class="math inline">\(10^5\)</span>个数）</p><p>有些题目可能要以这些序列的值为下标来做，因此需要把序列映射到从 <span class="math inline">\(0\)</span> 开始的连续的自然数。</p><p><img src="https://s1.ax1x.com/2023/07/15/pC5QM4J.png" style="zoom:80%;"></p><p><strong>离散化中常见的两个问题：</strong></p><ol type="1"><li><code>a[]</code>中可能有重复元素 -&gt; 去重</li><li>如何计算<code>x</code>离散化后的值 -&gt; 二分查找</li></ol><h2 id="模板">模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2023/07/04/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2023/07/04/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算">位运算</h1><p>常用的两种位运算的操作：求 <span class="math inline">\(n\)</span> 的第 <span class="math inline">\(k\)</span> 位数字和 <span class="math inline">\(n\)</span> 的最后一位</p><h2 id="n的二进制表示中第k位">1. n的二进制表示中第k位</h2><p><strong>思路：</strong></p><ol type="1"><li>先把第 <span class="math inline">\(k\)</span> 位移到最后一位，即<code>n &gt;&gt; k</code></li><li>看一下最低位是几，<code>x &amp; 1</code></li></ol><p>结合①和②，得到公式：<code>n &gt;&gt; k &amp; 1</code></p><blockquote><p>位移运算不会改变原数据的值，即<code>n &gt;&gt; k</code>前后<code>n</code>的值不变</p></blockquote><h2 id="n的二进制表示中最后一位">2. n的二进制表示中最后一位</h2><p><code>lowbit()</code>是树状数组的基本操作，<code>lowbit(x)</code>的作用是返回<code>x</code>的最后一位<code>1</code>。例如：如果二进制数<code>x = 1010</code>，则<code>lowbit(x)</code>返回的是<code>10</code>，即十进制数<code>2</code>；如果二进制数<code>x = 101000</code>，则<code>lowbit(x)</code>返回的是<code>1000</code>，即十进制数<code>8</code>。</p><p><strong>实现：</strong><code>lowbit(x) = x &amp; -x</code>。其中，<code>-x</code>是<code>x</code>的补码，即<code>x</code>取反加一</p><p><strong>应用：</strong>统计<code>x</code>的二进制表示中<code>1</code>的个数。每次把最后一位<code>1</code>减掉，当<code>x</code>的值为<code>0</code>时停止，统计循环次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求n的第k位数字: </span><br>n &gt;&gt; k &amp; <span class="hljs-number">1</span><br><span class="hljs-comment">// 返回n的最后一位1：</span><br><span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制的第k位</tag>
      
      <tag>lowbit( )</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针算法</title>
    <link href="/2023/07/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <url>/2023/07/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针算法">双指针算法</h1><ul><li><p><strong>第一类：</strong>指向的是<strong>两个序列</strong>，例如：归并排序中的双指针</p></li><li><p><strong>第二类：</strong>指向的是<strong>一个序列</strong>（常见），例如：快速排序的双指针</p></li></ul><h2 id="核心思想">1. 核心思想</h2><p>将下面的朴素算法的时间复杂度优化到 <span class="math inline">\(O(n)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        <span class="hljs-comment">// 操作</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么双指针算法的时间复杂度是 <span class="math inline">\(O(n)\)</span> ?</strong></p><p>双指针算法的时间复杂度为 <span class="math inline">\(O(n)\)</span> 的原因是，它通常在一个循环中使用两个指针进行迭代，而这两个指针相对于输入规模 <span class="math inline">\(n\)</span> 的数量级是线性的。</p><p>在双指针算法中，指针通常从输入序列的两端开始，然后向中间移动，根据特定的条件调整指针的位置。算法的终止条件可能是两个指针相遇或到达特定位置。</p><p>由于每次迭代中，指针的移动都是以固定的步长进行的，而且指针从两个方向同时移动，因此整个算法的执行时间与输入规模 <span class="math inline">\(n\)</span> 成线性关系。换句话说，算法的运行时间随着输入规模的增加而线性增长。</p><p>需要注意的是，虽然双指针算法的时间复杂度通常是 <span class="math inline">\(O(n)\)</span>，但也可以有特殊情况下的变体，其时间复杂度可能是 <span class="math inline">\(O(n^2)\)</span> 或其他不同的复杂度。这取决于算法的具体实现和问题的特定要求。但是，一般而言，双指针算法的时间复杂度是线性的，即 <span class="math inline">\(O(n)\)</span>。</p></blockquote><h2 id="例子">2. 例子</h2><p><strong>题目要求：</strong></p><p>输入一个字符串，其中包含多个单词，每个单词用空格隔开，输出每个单词。（假定字符串开始时没有空格，且每个单词之间只有一个空格）</p><p><strong>分析：</strong></p><p><img src="https://s1.ax1x.com/2023/07/15/pC5M5nK.png" style="zoom:80%;"></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">1000</span>];<br>    <span class="hljs-built_in">gets</span>(str);<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; str[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++;<br>        <span class="hljs-comment">// 这道题的具体逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; k++) cout &lt;&lt; str[k];<br>        cout &lt;&lt; endl;<br>        i = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板">3. 模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j++ ;<br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br><span class="hljs-comment">// 常见问题分类：</span><br>    <span class="hljs-comment">// (1) 对于一个序列，用两个指针维护一段区间</span><br>    <span class="hljs-comment">// (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></code></pre></td></tr></table></figure><p><strong>总结（双指针算法的实现思路）</strong></p><ol type="1"><li>写出题目对应的暴力解法（时间复杂度为 <span class="math inline">\(O(n^2)\)</span>），寻找两个循环索引 <span class="math inline">\(i、j\)</span> 之间的单调关系</li><li>如果有单调关系的话，利用其单调关系，把状态数量由 <span class="math inline">\(n^2\)</span> 变成 <span class="math inline">\(n\)</span>，从而把时间复杂度由 <span class="math inline">\(O(n^2)\)</span> 变成 <span class="math inline">\(O(n)\)</span></li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2023/07/02/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2023/07/02/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和与差分">前缀和与差分</h1><p><strong>差分：</strong><span class="math inline">\(a_1\)</span>、<span class="math inline">\(a_2\)</span>、<span class="math inline">\(a_3\)</span>、……、<span class="math inline">\(a_n\)</span> （下标从 <span class="math inline">\(1\)</span> 开始）</p><p><strong>前缀和：</strong><span class="math inline">\(S_1\)</span>、<span class="math inline">\(S_2\)</span>、<span class="math inline">\(S_3\)</span>、……、<span class="math inline">\(S_n\)</span> 其中，<span class="math inline">\(S_i=a_1+a_2+a_3+...+a_i\)</span> （下标从 <span class="math inline">\(1\)</span> 开始，定义 <span class="math inline">\(S_0=0\)</span>）</p><h2 id="前缀和">1. 前缀和</h2><h4 id="涉及到的两个问题">1. 涉及到的两个问题</h4><ol type="1"><li><p>如何求 <span class="math inline">\(S_i\)</span> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一维前缀和的初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<span class="hljs-comment">// 前缀和的初始化</span><br><span class="hljs-comment">// 二维前缀和的初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        s[i][j] = a[i][j] + s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li><li><p>前缀和数组 <span class="math inline">\(S_i\)</span> 的作用：快速求出原数组中的一段数的和。</p><blockquote><p><strong>前缀和数组作用的例子：</strong>假设题目要求求出数组中<code>[l, r]</code>的数的和（区间和的计算）</p><ul><li>如果没有前缀和数组，则需循环一遍求解，此时时间复杂度为 <span class="math inline">\(O(n)\)</span></li><li>如果有前缀和数组，则可直接计算得出 <span class="math inline">\(S_r-S_{l-1}\)</span>，此时时间复杂度为 <span class="math inline">\(O(1)\)</span></li></ul></blockquote></li></ol><h4 id="为什么前缀和的下标从1开始">2. 为什么前缀和的下标从1开始</h4><p><strong>主要是处理边界问题：</strong>当需要求数组<code>[1, t]</code>的数的和的时候，可以直接通过 <span class="math inline">\(S_t-S_0\)</span>，不用考虑边界问题。同时，这也是把 <span class="math inline">\(S_0\)</span> 定义为 <span class="math inline">\(0\)</span> 的原因。虽然该问题可以直接以 <span class="math inline">\(S_t\)</span> 为答案，但是为了统一计算公式，选择这种计算方法。</p><h3 id="一维前缀和">1.1 一维前缀和</h3><p>作用：<strong>快速求出某一区间的和</strong></p><p><strong>原数组：</strong><span class="math inline">\(a_i\)</span></p><p><strong>前缀和数组：</strong><span class="math inline">\(S_i\)</span></p><p><strong>区间和计算公式：</strong><span class="math inline">\([l,\ r]=S_r-S_{l-1}\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="二维前缀和">1.2 二维前缀和</h3><p>与一维前缀和类似，二维前缀和是为了<strong>快速求出某一子矩阵的和</strong></p><p><strong>原数组：</strong><span class="math inline">\(a_{ij}\)</span></p><p><strong>前缀和数组：</strong><span class="math inline">\(S_{ij}\)</span></p><p><strong>子矩阵和计算公式：</strong> <span class="math display">\[\left[ \begin{matrix}    \left( x_1, y_1 \right)&amp;        \left( x_1, y_2 \right)\\    \left( x_2, y_1 \right)&amp;        \left( x_2, y_2 \right)\\\end{matrix} \right] =S_{x_2y_2}-S_{x_1-1 y_2}-S_{x_2\,\,y_1-1}+S_{x_1-1 y_1-1}\]</span> <img src="https://s1.ax1x.com/2023/07/15/pC5Mapn.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">S[i, j] =  <span class="hljs-comment">// 第i行j列格子左上部分所有元素的和</span><br><span class="hljs-comment">// 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/15/pC5Mw60.png" style="zoom:80%;"></p><h2 id="差分">2. 差分</h2><h4 id="差分的作用">1. 差分的作用</h4><p>对于数组 <span class="math inline">\(a_i\ (i=1,2,3,…,n)\)</span>，其前缀和为 <span class="math inline">\(s_i\ (i = 1,2,3,…,n)\)</span>。<span class="math inline">\(a_i\)</span> 为 <span class="math inline">\(s_i\)</span> 的差分，满足 <span class="math inline">\(a_i\ = s_i \ - \ s_{i-1}\)</span>，即： <span class="math display">\[a_1 = s_1\\a_2 = s_2-s_1\\a_3 = s_3-s_2\\a_4 = s_4-s_3\\……\\a_n = s_n-s_{n-1}\]</span> <strong>作用：</strong>对于前缀和数组 <span class="math inline">\(s_i\)</span> ，如果需要使其从第 <span class="math inline">\(l\)</span> 项开始到第 <span class="math inline">\(r\)</span> 项每项都增加一个常数 <span class="math inline">\(C\)</span> 。如果直接对前缀和数组 <span class="math inline">\(s_i\)</span> 操作的话，即对 <span class="math inline">\(s_i\ (i = l,l+1,…,r)\)</span> 每一项都增加一个常数 <span class="math inline">\(C\)</span>，程序的时间复杂度为 <span class="math inline">\(O(n)\)</span>；如果对差分数组 <span class="math inline">\(a_i\)</span> 操作的话，即使 <span class="math inline">\(a_l + C\)</span> 、<span class="math inline">\(a_{r+1} - C\)</span>，程序的时间复杂度为 <span class="math inline">\(O(1)\)</span>。</p><h3 id="一维差分">2.1 一维差分</h3><p><strong>作用：</strong>给一维数组的一段加上一个值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br></code></pre></td></tr></table></figure><blockquote><p><strong>过程：</strong></p><ol type="1"><li><p>定义前缀和数组，并输入初值（给 <span class="math inline">\(s_i\)</span> 赋初值）</p></li><li><p>根据前缀和数组的值，给差分数组赋初值（给 <span class="math inline">\(a_i\)</span> 赋值）</p><p>对于差分数组中的第 <span class="math inline">\(i\)</span> 个元素，采用插入的方式：对于区间<code>[i,i]</code>插入<code>s[i]</code>，即<code>a[i] + s[i]</code>、<code>a[i+1] - s[i]</code></p></li><li><p>根据差分数组，求出其前缀和即可</p></li></ol></blockquote><h3 id="二维差分">2.2 二维差分</h3><p><strong>作用：</strong>给二维数组数组的一个子矩阵加上一个值</p><p><img src="https://s1.ax1x.com/2023/07/15/pC5Ms7F.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></td></tr></table></figure><blockquote><p>过程同一维差分，只不过计算差分数组的方式不同</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度</title>
    <link href="/2023/07/01/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/2023/07/01/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度">高精度</h1><blockquote><p><code>A</code>和<code>B</code>的位数约为<span class="math inline">\(10^6\)</span>，即<code>len(A)</code>和<code>len(B)</code>的结果为<span class="math inline">\(10^6\)</span></p><p><code>a</code>的数值小于等于<span class="math inline">\(10^9\)</span>，即<code>a&lt;=10^9</code></p></blockquote><h2 id="大整数是如何表示的">1. 大整数是如何表示的</h2><p>用<code>int</code>肯定是不行的，一般把大整数存储在数组里，并且要存储的数的最低位要放在数组索引为<code>0</code>的位置，即倒序存储。</p><blockquote><p><strong>大整数存储要倒序的原因：</strong></p><p>在对大整数做运算时，很可能出现进位的情况。当正序存储且需要进位时，就需要把数组中的所有元素后移一位，腾出最高位的空间。但是这会大大提高程序运行的时间复杂度，因此选择使用倒序存储。</p></blockquote><p>大整数的运算是一个模拟人工加法/减法/乘法/除法的过程。</p><blockquote><p>通常以字符串的形式读入大整数，然后通过<code>for</code>循环遍历字符串中的每个元素，存储到<code>vector&lt;int&gt;</code>中。注意，在存储的时候，要将字符串中的字符元素转化为整型元素，即<code>a[i] - '\0'</code>.</p></blockquote><h2 id="两个比较大的整数相加ab">2. 两个比较大的整数相加<code>A+B</code></h2><h3 id="实现原理">2.1 实现原理</h3><p><img src="https://s1.ax1x.com/2023/07/14/pC4xFN4.png" style="zoom:100%;"></p><p><strong>串行进位加法器</strong>：从最低位开始计算，每一位的运算都是<span class="math inline">\(A_i+B_i+t\)</span>，其中<span class="math inline">\(A_i\)</span>是被加数的第<span class="math inline">\(i\)</span>位、<span class="math inline">\(B_i\)</span>是加数的第<span class="math inline">\(i\)</span>位、<span class="math inline">\(t\)</span>是上一位的进位。最初状态时，<span class="math inline">\(t\)</span>被赋初值<span class="math inline">\(0\)</span>，相当于向最低位的进位为<span class="math inline">\(0\)</span>。</p><h3 id="代码模板">2.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span><span class="hljs-comment">// 接收结果时, 可以使用auto类型</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    vector&lt;int&gt; C;</span><br><span class="hljs-comment">    int t = 0;</span><br><span class="hljs-comment">    for (int i = 0; i &lt; A.size() || i &lt; B.size(); i ++ )</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        if (i &lt; A.size()) t += A[i];</span><br><span class="hljs-comment">        if (i &lt; B.size()) t += B[i];</span><br><span class="hljs-comment">        C.push_back(t % 10);</span><br><span class="hljs-comment">        t /= 10;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    if (t) C.push_back(t);</span><br><span class="hljs-comment">    return C;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="两个比较大的整数相减a-b">3. 两个比较大的整数相减<code>A-B</code></h2><h3 id="实现原理-1">3.1 实现原理</h3><p><img src="https://s1.ax1x.com/2023/07/14/pC4xk4J.png" style="zoom:100%;"></p><p><strong>(1) 两步实现：</strong></p><ol type="1"><li><p>判断<code>A</code>和<code>B</code>的大小。如果<code>A&gt;=B</code>，直接算<code>A-B</code>；如果<code>A&lt;B</code>，计算<code>B-A</code>后加上负号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断是否有 A &gt;= B</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span>(A[i] != B[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<span class="hljs-comment">// A &gt; B</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// A = B</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算<code>A-B</code></p></li></ol><p><strong>(2) 对于每一位的计算：</strong>需要计算<span class="math inline">\(A_i-B_i-t\)</span>，其中<span class="math inline">\(A_i\)</span>是被减数的第<span class="math inline">\(i\)</span>位、<span class="math inline">\(B_i\)</span>是减数的第<span class="math inline">\(i\)</span>位、<span class="math inline">\(t\)</span>是上一位借位。最初状态时，<span class="math inline">\(t\)</span>被赋初值<span class="math inline">\(0\)</span>，相当于向最低位的借位为<span class="math inline">\(0\)</span>。如果其结果<code>&gt;=0</code>，则直接为该位的计算结果；如果其结果<code>&lt;0</code>，则说明该位不够减，应该向上一位借位，从而在结果上<code>+10</code>。<span class="math inline">\(t\)</span>根据借位与否，决定其之后的值是1还是0。</p><h3 id="代码模板-1">3.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 去掉前导0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一个大整数乘一个小整数aa">4. 一个大整数乘一个小整数<code>A*a</code></h2><h3 id="实现原理-2">4.1 实现原理</h3><p>对于每一位的计算：分别计算当前位于乘数的乘积。计算 <span class="math inline">\((A_i*b+t)\%10\)</span> 作为当前位的计算结果，<span class="math inline">\((A_i+b+t)/10\)</span> 作为当前位的进位，并赋值给 <span class="math inline">\(t\)</span>。其中，<span class="math inline">\(A\)</span> 是乘数（大整数）、<span class="math inline">\(b\)</span> 是小整数、<span class="math inline">\(t\)</span> 是上一位的进位。</p><h3 id="代码模板-2">4.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<span class="hljs-comment">// 当前位的计算结果</span><br>        t /= <span class="hljs-number">10</span>;<span class="hljs-comment">// 进位</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一个大整数除以一个小整数ab">5. 一个大整数除以一个小整数<code>A/b</code></h2><h3 id="实现原理-3">5.1 实现原理</h3><p>模拟<strong>人工除法</strong>的过程：定义被除数为 <span class="math inline">\(A\)</span>（大整数）、除数为 <span class="math inline">\(b\)</span>（小整数）、余数 <span class="math inline">\(r\)</span>（小整数），初始时 <span class="math inline">\(r\)</span> 的值定义的 <span class="math inline">\(0\)</span>。计算每一位的时候，<span class="math inline">\((r*10+A_i)/b\)</span> 作为当前位的商，<span class="math inline">\((r*10+A_i)\%b\)</span> 作为当前位的余数。</p><p>计算结束后，由于计算结果不满足倒序存储，因此需要调用<code>reverse(C.begin(), C.end())</code>反转存储结果，使结果满足倒序存储。</p><h3 id="代码模板-3">5.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度加法</tag>
      
      <tag>高精度减法</tag>
      
      <tag>高精度乘法</tag>
      
      <tag>高精度除法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2023/07/01/%E4%BA%8C%E5%88%86/"/>
    <url>/2023/07/01/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二分">二分</h1><p>二分的本质不是单调性。有单调性的题目一定可以二分，可以二分的题目不一定必须有单调性。</p><h2 id="整数二分">1. 整数二分</h2><p><img src="https://s1.ax1x.com/2023/07/14/pC4vynK.png" style="zoom:80%;"></p><h3 id="主要思想">1.1 主要思想</h3><p>在一个区间内部，使用二分的方法得到答案。每次选择答案所在的区间进行二分，且每次都能保证区间内有答案。对于有解的问题，二分得到的是正确答案；对于无解的题目，二分得到的是答案应该存在的位置。</p><h3 id="整数二分的实现过程">1.2 整数二分的实现过程</h3><ol type="1"><li>找一个中间值，即<code>mid = (l + r) / 2</code></li><li>（假设判断的是红色的性质）每次判断一下中间值是否满足性质，即<code>if(check(mid))</code><ul><li>情况一：<code>true</code><ul><li>说明<code>mid</code>满足该性质，因此<code>ans</code>所在区间为<code>[mid, r]</code></li><li>更新方式：<code>l = mid</code></li></ul></li><li>情况二：<code>false</code><ul><li>说明<code>mid</code>不满足该性质，因此<code>ans</code>所在区间为<code>[l, mid - 1]</code></li><li>更新方式：<code>r = mid - 1</code></li></ul></li></ul></li><li>（假设判断的是绿色的性质）每次判断一下中间值是否满足性质，即<code>if(check(mid))</code><ul><li>情况一：<code>true</code><ul><li>说明<code>mid</code>满足该性质，因此<code>ans</code>所在区间为<code>[l, mid]</code></li><li>更新方式：<code>r = mid</code></li></ul></li><li>情况二：<code>false</code><ul><li>说明<code>mid</code>不满足该性质，因此<code>ans</code>所在区间为<code>[mid + 1, r]</code></li><li>更新方式：<code>l = mid + 1</code></li></ul></li></ul></li></ol><blockquote><p><strong>中间值“是否+1”的问题</strong></p><p>如果<code>mid = (l + r) / 2</code>，当<code>l = r - 1</code>时，求得<code>mid</code>的值为<code>l</code>，倘若此时<code>check()</code>正好取得<code>true</code>，则会执行<code>l = mid</code>，即<code>l</code>更新后的值还是<code>l</code>，就会陷入死循环状态。</p></blockquote><h3 id="模板">1.3 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分">2. 浮点数二分</h2><h3 id="浮点数二分的实现过程">2.1 浮点数二分的实现过程</h3><p><img src="https://s1.ax1x.com/2023/07/14/pC4vrX6.png" style="zoom:80%;"></p><p>由于浮点数除法的结果仍然是浮点数，是保留精度的，其与整数除法的整除存在一定的差异。因此，浮点数二分不用考虑<strong>边界问题</strong>，其能够准确的把两个区间分为两部分。</p><h3 id="模板-1">2.2 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<span class="hljs-comment">// 注意是大-小, 或者直接用abs()函数取绝对值</span><br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>经验</strong>：如果题目要求保留4位小数，则<code>r-l</code>应该小于<code>1e-6</code>；如果题目要求保留5位小数，则<code>r-l</code>应该小于<code>1e-7</code>；如果题目要求保留6位小数，则<code>r-l</code>应该小于<code>1e-8</code>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整数二分</tag>
      
      <tag>浮点数二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2023/06/29/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/06/29/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序">归并排序</h1><h2 id="主要思想">1. 主要思想</h2><p>归并排序算法的主要思想：<strong>分治</strong></p><h2 id="归并排序的步骤">2. 归并排序的步骤</h2><ol type="1"><li><p>确定分界点</p><ul><li><p>以数组的中间位置为分界点，分为左右两部分。</p></li><li><p><code>mid = (l + r) / 2</code></p></li></ul></li><li><p>递归排序左右两部分</p><ul><li>递归左右两部分，对最小的单位进行排序</li></ul></li><li><p>归并——合二为一<strong>（重难点）</strong></p><ul><li>把两个有序的数组合并为一个有序的数组</li></ul></li></ol><ul><li><strong>时空复杂度：</strong><ul><li>时间复杂度：<span class="math inline">\(O(nlog_2n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ul></li></ul><h2 id="实现过程双指针算法">3. 实现过程（双指针算法）</h2><p><img src="https://s1.ax1x.com/2023/07/14/pC4vPfA.png"></p><blockquote><p>图片摘自：http://t.csdn.cn/RNb0o</p></blockquote><h2 id="模板">4. 模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前区间是否只有一个数或者没有数</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-comment">// 排序当前数组</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++] = q[j++];<br>    <span class="hljs-comment">// 处理某数组的元素全部排序完成，另一个数组中包含元素的情况</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];<br>    <span class="hljs-comment">// 把临时数组中排好序的内容转移到要排序的数组</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2023/06/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/06/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序">快速排序</h1><h2 id="主要思想">1. 主要思想</h2><p>快速排序算法的主要思想：<strong>分治</strong></p><h2 id="快速排序的步骤">2. 快速排序的步骤</h2><ol type="1"><li>确定分界点<code>x</code><ul><li>确定一个分界点，用于将数组划分为两个子数组</li><li>常用方式：取边界（<code>q[l]</code>或<code>q[r]</code>）、取中间值（<code>q[(l+r)/2]</code>）、取区间内随机一个数</li></ul></li><li>调整区间<strong>（重难点）</strong><ul><li>根据分界点，把区间分为两部分，使得左边区间的数都<code>&lt;=x</code>，右边区间的数都<code>&gt;=x</code></li></ul></li><li>递归处理左右两段区间</li></ol><p><img src="https://s1.ax1x.com/2023/07/14/pC4LFqe.png"></p><h2 id="如何调整区间">3. 如何调整区间</h2><h3 id="方法一暴力法思想简单占用额外空间">方法一：暴力法（思想简单、占用额外空间）</h3><ul><li><strong>基本思想：</strong><ul><li><p>首先，开两个额外的数组<code>a[]</code>、<code>b[]</code>。</p></li><li><p>然后，扫描<code>q[l] ~ q[r]</code>的每一个数。如果<code>q[i]&lt;=x</code>，则把其插入到数组<code>a[]</code>中；如果<code>q[i]&gt;x</code>，则把其插入到数组<code>b[]</code>中。</p></li><li><p>最后，先遍历数组<code>a[]</code>，再遍历数组<code>b[]</code>，把数组中的数依次存储到数组<code>q[]</code>中。</p></li></ul></li><li><strong>时空复杂度：</strong><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ul></li></ul><h3 id="方法二双指针法优美而简洁">方法二：双指针法（优美而简洁）</h3><blockquote><p><strong>要点：</strong>在任何时刻，<code>i</code>指针左边所有的数都一定<code>&lt;=x</code>，<code>j</code>指针右边的数都一定<code>&gt;=x</code>。</p><p><strong>原因：</strong>当<code>i</code>指针在遍历时，如果当前数满足<code>&lt;x</code>的条件时，则<code>i</code>会指向下一个数；如果当前数不满足<code>&lt;x</code>的条件时，<code>i</code>指针会等待<code>j</code>指针找到一个<code>&gt;=x</code>的数与之交换，从而使得当前数也满足<code>&lt;=x</code>的条件。最终，<code>i</code>指针左侧所有的数都一定<code>&lt;=x</code>。对于<code>j</code>指针，同理。</p></blockquote><ul><li><p><strong>基本思想：</strong></p><ul><li><p>定义两个指针<code>i</code>和<code>j</code>，分别指向要排序的数组<code>q</code>的两端</p><p><img src="https://s1.ax1x.com/2023/07/14/pC4LirD.png" alt="pC4LirD.png"></p></li><li><p>两个指针分别往中间走，即<code>i++</code>和<code>j--</code>。</p><ul><li><p>首先，移动<code>i</code>指针。当<code>i</code>指向的值满足<code>q[i]&lt;x</code>时，<code>i</code>做自增运算，即<code>i++</code>；否则，<code>i</code>指针停止移动。</p></li><li><p>然后，移动<code>j</code>指针。当<code>j</code>指向的值满足<code>q[j]&gt;x</code>时，<code>j</code>做自减运算，即<code>j--</code>；否则，<code>j</code>指针停止移动。</p><p><img src="https://s1.ax1x.com/2023/07/14/pC4LPKO.png" alt="pC4LPKO.png"></p></li></ul></li><li><p>做完上述指针移动操作后，<code>i</code>指针左边所有的值都满足<code>q[]&lt;x</code>，<code>j</code>指针右边所有的值都满足<code>q[]&gt;x</code>，但此时<code>q[i]&gt;=x</code>且<code>q[j]&lt;=x</code>。为满足要求（调整区间），需要通过交换<code>i</code>和<code>j</code>指向的值，使得<code>i</code>指向的值满足<code>q[i]&lt;=x</code>、<code>j</code>指向的值满足<code>q[j]&gt;=x</code>，从而使程序能够继续运行。</p><p><img src="https://s1.ax1x.com/2023/07/14/pC4LmGt.png" alt="pC4LmGt.png"></p></li><li><p>当<code>i&gt;j</code>时，说明已经得到了两端调整后的区间（此时，<code>i</code>指针左边的值都满足小于等于x，<code>j</code>指针右边的值都满足大于等于x）</p><p><img src="https://s1.ax1x.com/2023/07/14/pC4L9xK.png" alt="pC4L9xK.png"></p></li></ul></li><li><p><strong>时空复杂度：</strong></p></li><li><p>时间复杂度：<span class="math inline">\(O(nlog_2n)\)</span></p></li><li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li></ul><h2 id="模板">4. 模板</h2><h3 id="模板-1">(1) 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 模板1☆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前要排序的子数组中的元素个数是否&lt;=1</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 调整区间</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<span class="hljs-comment">// 这里尽量用 j</span><br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-comment">// 模板2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前要排序的子数组中的元素个数是否&lt;=1</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 调整区间</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关于边界问题">(2) 关于边界问题</h3><p><strong>正确代码1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<span class="hljs-comment">// 或者x = q[(l+r)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/14/pC4LAVH.png"></p><p><strong>错误代码1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[r];<span class="hljs-comment">// 或者x = q[(l+r)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/14/pC4LEad.png"></p><p><strong>正确代码2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[r];<span class="hljs-comment">// 或者x = q[(l+r+1)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/14/pC4LVIA.png"></p><p><strong>错误代码2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<span class="hljs-comment">// 或者x = q[(l+r+1)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/14/pC4LePI.png"></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
