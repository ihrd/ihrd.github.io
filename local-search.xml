<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2023/06/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/06/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="1-主要思想"><a href="#1-主要思想" class="headerlink" title="1.  主要思想"></a>1.  主要思想</h2><p>快速排序算法的主要思想：&#x3D;&#x3D;分治&#x3D;&#x3D;</p><h2 id="2-快速排序的步骤"><a href="#2-快速排序的步骤" class="headerlink" title="2. 快速排序的步骤"></a>2. 快速排序的步骤</h2><ol><li>确定分界点<code>x</code><ul><li>确定一个分界点，用于将数组划分为两个子数组</li><li>常用方式：取边界（<code>q[l]</code>或<code>q[r]</code>）、取中间值（<code>q[(l+r)/2]</code>）、取区间内随机一个数</li></ul></li><li>调整区间&#x3D;&#x3D;<strong>（重难点）</strong>&#x3D;&#x3D;<ul><li>根据分界点，把区间分为两部分，使得左边区间的数都<code>&lt;=x</code>，右边区间的数都<code>&gt;=x</code></li></ul></li><li>递归处理左右两段区间</li></ol><img src="./img/image-20230701204647128.png" alt="image-20230701204647128" style="zoom:90%;" /><h2 id="3-如何调整区间"><a href="#3-如何调整区间" class="headerlink" title="3. 如何调整区间"></a>3. 如何调整区间</h2><h3 id="方法一：暴力法（思想简单、占用额外空间）"><a href="#方法一：暴力法（思想简单、占用额外空间）" class="headerlink" title="方法一：暴力法（思想简单、占用额外空间）"></a>方法一：暴力法（思想简单、占用额外空间）</h3><ul><li><strong>基本思想：</strong><ul><li><p>首先，开两个额外的数组<code>a[]</code>、<code>b[]</code>。</p></li><li><p>然后，扫描<code>q[l] ~ q[r]</code>的每一个数。如果<code>q[i]&lt;=x</code>，则把其插入到数组<code>a[]</code>中；如果<code>q[i]&gt;x</code>，则把其插入到数组<code>b[]</code>中。</p></li><li><p>最后，先遍历数组<code>a[]</code>，再遍历数组<code>b[]</code>，把数组中的数依次存储到数组<code>q[]</code>中。</p></li></ul></li><li><strong>时空复杂度：</strong><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul></li></ul><h3 id="方法二：双指针法（优美而简洁）"><a href="#方法二：双指针法（优美而简洁）" class="headerlink" title="方法二：双指针法（优美而简洁）"></a>方法二：双指针法（优美而简洁）</h3><blockquote><p><strong>要点：</strong>在任何时刻，<code>i</code>指针左边所有的数都一定<code>&lt;=x</code>，<code>j</code>指针右边的数都一定<code>&gt;=x</code>。</p><p><strong>原因：</strong>当<code>i</code>指针在遍历时，如果当前数满足<code>&lt;x</code>的条件时，则<code>i</code>会指向下一个数；如果当前数不满足<code>&lt;x</code>的条件时，<code>i</code>指针会等待<code>j</code>指针找到一个<code>&gt;=x</code>的数与之交换，从而使得当前数也满足<code>&lt;=x</code>的条件。最终，<code>i</code>指针左侧所有的数都一定<code>&lt;=x</code>。对于<code>j</code>指针，同理。</p></blockquote><ul><li><p><strong>基本思想：</strong></p><ul><li><p>定义两个指针<code>i</code>和<code>j</code>，分别指向要排序的数组<code>q</code>的两端</p><img src="/img/image-20230630201053672.png" alt="image-20230630201053672" style="zoom:80%;" /></li><li><p>两个指针分别往中间走，即<code>i++</code>和<code>j--</code>。</p><ul><li><p>首先，移动<code>i</code>指针。当<code>i</code>指向的值满足<code>q[i]&lt;x</code>时，<code>i</code>做自增运算，即<code>i++</code>；否则，<code>i</code>指针停止移动。</p></li><li><p>然后，移动<code>j</code>指针。当<code>j</code>指向的值满足<code>q[j]&gt;x</code>时，<code>j</code>做自减运算，即<code>j--</code>；否则，<code>j</code>指针停止移动。</p><img src="/img/image-20230630201113963.png" alt="image-20230630201113963" style="zoom:80%;" /></li></ul></li><li><p>做完上述指针移动操作后，<code>i</code>指针左边所有的值都满足<code>q[]&lt;x</code>，<code>j</code>指针右边所有的值都满足<code>q[]&gt;x</code>，但此时<code>q[i]&gt;=x</code>且<code>q[j]&lt;=x</code>。为满足要求（调整区间），需要通过交换<code>i</code>和<code>j</code>指向的值，使得<code>i</code>指向的值满足<code>q[i]&lt;=x</code>、<code>j</code>指向的值满足<code>q[j]&gt;=x</code>，从而使程序能够继续运行。</p><img src="/img/image-20230630201127663.png" alt="image-20230630201127663" style="zoom:80%;" /></li><li><p>当<code>i&gt;j</code>时，说明已经得到了两端调整后的区间（此时，<code>i</code>指针左边的值都满足小于等于x，<code>j</code>指针右边的值都满足大于等于x）</p><img src="/img/image-20230630201141083.png" alt="image-20230630201141083" style="zoom:80%;" /></li></ul></li><li><p><strong>时空复杂度：</strong></p><ul><li><p>时间复杂度：$O(nlog_2n)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul></li></ul><h2 id="4-模板"><a href="#4-模板" class="headerlink" title="4. 模板"></a>4. 模板</h2><h3 id="x3D-x3D-1-模板-x3D-x3D"><a href="#x3D-x3D-1-模板-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;(1) 模板&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>(1) 模板</strong>&#x3D;&#x3D;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 模板1☆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前要排序的子数组中的元素个数是否&lt;=1</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 调整区间</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<span class="hljs-comment">// 这里尽量用 j</span><br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-comment">// 模板2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前要排序的子数组中的元素个数是否&lt;=1</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 调整区间</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-关于边界问题"><a href="#2-关于边界问题" class="headerlink" title="(2) 关于边界问题"></a>(2) 关于边界问题</h3><p><strong>正确代码1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<span class="hljs-comment">// 或者x = q[(l+r)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/image-20230521233936246.png" alt="image-20230521233936246"  /><p><strong>错误代码1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[r];<span class="hljs-comment">// 或者x = q[(l+r)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/image-20230521235108658.png" alt="image-20230521235108658" style="zoom:100%;" /><p><strong>正确代码2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[r];<span class="hljs-comment">// 或者x = q[(l+r+1)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/image-20230521234619935.png" alt="image-20230521234619935" style="zoom:100%;" /><p><strong>错误代码2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<span class="hljs-comment">// 或者x = q[(l+r+1)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/image-20230521234340627.png" alt="image-20230521234340627" style="zoom:100%;" />]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
