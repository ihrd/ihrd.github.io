<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AcWing240. 食物链</title>
    <link href="/2023/07/25/%E9%A3%9F%E7%89%A9%E9%93%BE/"/>
    <url>/2023/07/25/%E9%A3%9F%E7%89%A9%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="acwing240.-食物链">AcWing240. 食物链</h1><blockquote><p>原题链接：<a href="https://www.acwing.com/problem/content/description/242/">240. 食物链 - AcWing题库</a></p></blockquote><h2 id="一题目">一、题目</h2><p>动物王国中有三类动物 <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>，这三类动物的食物链构成了有趣的环形。</p><p><span class="math inline">\(A\)</span> 吃 <span class="math inline">\(B\)</span>，<span class="math inline">\(B\)</span> 吃 <span class="math inline">\(C\)</span>，<span class="math inline">\(C\)</span> 吃 <span class="math inline">\(A\)</span>。</p><p>现有 <span class="math inline">\(N\)</span> 个动物，以 <span class="math inline">\(1∼N\)</span> 编号。</p><p>每个动物都是 <span class="math inline">\(A,B,C\)</span> 中的一种，但是我们并不知道它到底是哪一种。</p><p>有人用两种说法对这 <span class="math inline">\(N\)</span> 个动物所构成的食物链关系进行描述：</p><p>第一种说法是 <code>1 X Y</code>，表示 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是同类。</p><p>第二种说法是 <code>2 X Y</code>，表示 <span class="math inline">\(X\)</span> 吃 <span class="math inline">\(Y\)</span>。</p><p>此人对 <span class="math inline">\(N\)</span> 个动物，用上述两种说法，一句接一句地说出 <span class="math inline">\(K\)</span> 句话，这 <span class="math inline">\(K\)</span> 句话有的是真的，有的是假的。</p><p>当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ol type="1"><li>当前的话与前面的某些真的话冲突，就是假话；</li><li>当前的话中 <span class="math inline">\(X\)</span> 或 <span class="math inline">\(Y\)</span> 比 <span class="math inline">\(N\)</span> 大，就是假话；</li><li>当前的话表示 <span class="math inline">\(X\)</span> 吃 <span class="math inline">\(X\)</span>，就是假话。</li></ol><p>你的任务是根据给定的 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(K\)</span> 句话，输出假话的总数。</p><h4 id="输入格式">输入格式</h4><p>第一行是两个整数 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(K\)</span>，以一个空格分隔。</p><p>以下 <span class="math inline">\(K\)</span> 行每行是三个正整数 <span class="math inline">\(D\)</span>，<span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span>，两数之间用一个空格隔开，其中 <span class="math inline">\(D\)</span> 表示说法的种类。</p><p>若 <span class="math inline">\(D=1\)</span>，则表示 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是同类。</p><p>若 <span class="math inline">\(D=2\)</span>，则表示 <span class="math inline">\(X\)</span> 吃 <span class="math inline">\(Y\)</span>。</p><h4 id="输出格式">输出格式</h4><p>只有一个整数，表示假话的数目。</p><h4 id="数据范围">数据范围</h4><p><span class="math inline">\(1≤N≤50000\)</span> <span class="math inline">\(0≤K≤100000\)</span></p><h4 id="输入样例">输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs input">100 7<br>1 101 1 <br>2 1 2<br>2 2 3 <br>2 3 3 <br>1 1 3 <br>2 3 1 <br>1 5 5<br></code></pre></td></tr></table></figure><h4 id="输出样例">输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">3<br></code></pre></td></tr></table></figure><h2 id="二分析">二、分析</h2><p>由题意知，<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>、<span class="math inline">\(C\)</span> 三类动物之间的关系为：</p><p><img src="https://s1.ax1x.com/2023/07/25/pCXarvj.png" style="zoom:67%;"></p><p>假设节点<code>x</code>与根节点之间的距离为<code>d[x]</code>。若两个节点与根节点之间的距离模三相同，即<code>(d[x] - d[y]) % 3 == 0</code>，则表示两个节点是同类；若两个节点与根节点之间的距离模三差为 <span class="math inline">\(1\)</span>，即<code>(d[x] - d[y] - 1) % 3 == 0</code>，则表示两个节点是吃与被吃的关系，<code>x</code>节点吃<code>y</code>节点。</p><blockquote><p><strong>为什么不能直接比较两个节点与根节点之间的差值？</strong>、</p><p>因为距离是正值，差值可能为负值。当使用两个节点与根节点之间的差值计算时：</p><ul><li>比较两个节点是否为同类，差值比较<code>d[x] % 3 == d[y] % 3</code>。此时，如果<code>d[x] % 3</code>为负值、<code>d[y] % 3</code>为正值（假设前者为 <span class="math inline">\(d[x] = -4\)</span>、后者为 <span class="math inline">\(d[y] = 2\)</span>），易知<code>d[x]</code>和<code>d[y]</code>是同类，但是通过差值判断的结论却恰恰相反。通过作差或转为符号相同的即可判断，即<code>d[x] - d[y] % 3 == 0</code>或<code>(d[x] % 3 + 3) % 3 == (d[y] % 3 + 3) % 3</code>。</li><li>比较两个节点是否存在吃与被吃的关系同理。</li></ul></blockquote><p>在并查集中，将所有动物（节点）都存储在一个集合中，通过其与根节点之间的距离表示动物的类别，通过不同类别的动物在集合中与根节点的距离不同可以表示动物之间的吃与被吃的关系。</p><p>如上图中，不同类别的动物在集合中与根节点的距离模三的结果不同，结果 <span class="math inline">\(0,1,2\)</span> 分别表示 <span class="math inline">\(A,B,C\)</span> 三种不同的动物。其中，<span class="math inline">\(0\)</span> 吃 <span class="math inline">\(2\)</span>、<span class="math inline">\(1\)</span> 吃 <span class="math inline">\(0\)</span>、<span class="math inline">\(2\)</span> 吃 <span class="math inline">\(1\)</span>。</p><h2 id="三题解">三、题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>;<br><span class="hljs-comment">// p[]表示当前结点的父节点, d[]表示与根节点之间的距离</span><br><span class="hljs-comment">// 与根节点距离模三为0 -&gt; 被与根节点距离模三为1的吃</span><br><span class="hljs-comment">// 与根节点距离模三为1 -&gt; 被与根节点距离模三为2的吃</span><br><span class="hljs-comment">// 与根节点距离模三为2 -&gt; 被与根节点距离模三为0的吃</span><br><span class="hljs-type">int</span> n, k, p[N], d[N], ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)<br>    &#123;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">find</span>(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 检查是否为假话</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> op, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt; n || y &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// 动物编号越界假话</span><br>    <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x), py = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)    <span class="hljs-comment">// x 和 y 是同一类</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (px == py &amp;&amp; (d[x] - d[y]) % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// x和y在一个集合中  不满足x和y是同一类的条件</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (px != py) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <span class="hljs-comment">// x 和 y 不在同一个集合中</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>)   <span class="hljs-comment">// x 吃 y</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (px == py &amp;&amp; (d[x] - d[y] - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// x 和 y 在一个集合中  x 不满足吃 y 的距离条件</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (px != py) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <span class="hljs-comment">// x 和 y 不在同一个集合中</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 重复出现相同条件</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br>    <span class="hljs-keyword">while</span> (k -- )<br>    &#123;<br>        <span class="hljs-type">int</span> op, x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);<br>        <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x), py = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(op, x, y)) &#123; ans++; <span class="hljs-keyword">continue</span>; &#125;  <span class="hljs-comment">// 假话</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (px != py)  <span class="hljs-comment">// x 和 y 不在同一个集合中, 更新 x 和 y 所在的集合</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br>            &#123;<br>                p[px] = py;     <span class="hljs-comment">// 设置x所在集合的根节点</span><br>                d[px] = d[y] - d[x];    <span class="hljs-comment">// 设置x到新的根节点的距离, 使x和y为同一类</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                p[px] = py;     <span class="hljs-comment">// 设置x所在集合的根节点</span><br>                d[px] = d[y] - d[x] + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 设置x到新的根节点的距离, 使x能够吃y</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/07/24/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/07/24/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集">并查集</h1><blockquote><p>朴素并查集、维护每个集合里面数量的并查集、计算偏移量的并查集</p></blockquote><p><strong>并查集的两个用途：</strong></p><ol type="1"><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol><blockquote><p>虽然暴力做法也可以实现，但是使用并查集可以在近乎 <span class="math inline">\(O(1)\)</span> 的时间复杂度内实现。</p></blockquote><h2 id="朴素并查集">2.5.1 朴素并查集</h2><h3 id="基本思想">基本思想：</h3><p>对于每个集合，用一个树来表示。树根的编号就是整个集合的编号，每个节点存储他的父节点编号，即<code>p[x]</code>表示<code>x</code>的父节点。</p><p><img src="https://s1.ax1x.com/2023/07/24/pCLaI8H.png" style="zoom:67%;"></p><p>其中，每个树的根节点的编号表示当前集合的编号，可以通过<code>p[x] == x</code>判断，非根节点的编号的<code>p[]</code>数组为其父节点的编号，如<code>p[x] = y</code>。</p><h3 id="如何查找节点属于哪个集合">如何查找节点属于哪个集合？</h3><p>例如，求节点<code>x</code>属于哪个集合？</p><p>可以通过数组<code>p[]</code>，判断其是否满足树根的条件，即是否满足<code>p[x] == x</code>。当不满足树根条件时，继续判断<code>p[p[x]] == p[x]</code>，直到满足树根条件为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(p[x] != x) x = p[x]<br></code></pre></td></tr></table></figure><h3 id="如何合并两个集合">如何合并两个集合？</h3><p>假设<code>px</code>是<code>x</code>的集合编号，<code>py</code>是<code>y</code>的集合编号，则合并操作的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">p[x] = y;<br></code></pre></td></tr></table></figure><h3 id="并查集的优化">并查集的优化</h3><p>在查找当前节点属于哪个集合的时候，每次都需要从当前节点遍历到根节点，且遍历的节点个数和树的高度呈正比。因此，对于一些情况（如，反复查找某个叶子节点），可能时间复杂度与暴力做法相比差不多。</p><p>此时，可以使用<strong>路径压缩</strong>优化。对于遍历过程中的每个节点，在遍历结束后，如果找到了根节点的话，所有经过的节点的<code>p[]</code>都指向根节点。</p><blockquote><p>并查集的优化方式主要有两种：<strong>路径压缩</strong> 和 <strong>按秩合并</strong></p><p>其中，路径压缩的优化效果显著，可以使并查集的时间复杂度近似于 <span class="math inline">\(O(1)\)</span>；而按秩合并对并查集的优化效果不如路径压缩显著。</p></blockquote><p><img src="https://s1.ax1x.com/2023/07/24/pCLao2d.png" style="zoom:80%;"></p><h3 id="代码模板">代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><h2 id="维护size的并查集">2.5.2 维护size的并查集</h2><p>所维护的 <code>size</code> 表示当前集合中点的个数，根节点编号为<code>x</code>，则当前集合中的点的个数为<code>size[x]</code>。当合并两个集合的时候，需要将集合的<code>size</code>想加，赋值给合并后的集合的<code>size</code>。</p><p><img src="https://s1.ax1x.com/2023/07/25/pCXaqVx.png" style="zoom:80%;"></p><h3 id="代码模板-1">代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><span class="hljs-type">int</span> p[N], size[N];<br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    size[i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>size[<span class="hljs-built_in">find</span>(b)] += size[<span class="hljs-built_in">find</span>(a)];<br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><h2 id="维护到祖宗节点距离的并查集">2.5.3 维护到祖宗节点距离的并查集</h2><h3 id="代码模板-2">代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><span class="hljs-type">int</span> p[N], d[N];<br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)<br>    &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = u;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    d[i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>朴素并查集</tag>
      
      <tag>维护size的并查集</tag>
      
      <tag>维护到祖宗节点距离的并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie树</title>
    <link href="/2023/07/22/Trie%E6%A0%91/"/>
    <url>/2023/07/22/Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="trie-树">Trie 树</h1><blockquote><p>Trie树，也叫字典树，是用来高效地<strong>存储</strong>和<strong>查找</strong>字符串集合的数据结构。</p></blockquote><h2 id="trie树的存储">1. Trie树的存储</h2><p>假设要在Trie树中存储字符串<code>abcdef</code>、<code>abdef</code>、<code>aced</code>、<code>bcdf</code>、<code>bcff</code>、<code>cdaa</code>、<code>bcdc</code>、<code>abc</code>（要么全是小写字母，要么全是大写字母，要么全是数字，要么全是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span>，而且字母的个数不会很多），在每个单词结尾的节点会做一个标记，表示存在一个以该节点所对应的字母结尾的单词，Trie树如下图所示：</p><p><img src="https://s1.ax1x.com/2023/07/24/pCLagDx.png" style="zoom: 50%;"></p><h2 id="trie树的查找">2. Trie树的查找</h2><p>Trie树的查找分为三种情况：</p><ol type="1"><li>查找成功。例如，查找字符串<code>aced</code>时，通过遍历Trie树到达节点<code>d</code>后，判断其存在标记，故查找成功。</li><li>由于最后一个节点不存在标记点而查找失败。例如，查找字符串<code>abcd</code>时，通过遍历Trie树找到了节点<code>d</code>，但是在节点<code>d</code>上不存在标记，因此查找失败。</li><li>由于不存在节点而查找失败。例如，查找字符串<code>abcf</code>，在遍历Trie树的时候，遍历到节点<code>c</code>，其下一个节点为<code>f</code>，但是在Trie树中当前节点<code>c</code>不存在一个<code>f</code>的后继节点，因此查找失败。</li></ol><p><img src="https://s1.ax1x.com/2023/07/24/pCLa2b6.png" style="zoom:80%;"></p><h2 id="代码模板">3. 代码模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-comment">// 0号点既是根节点，又是空节点</span><br><span class="hljs-comment">// son[][]存储树中每个节点的子节点</span><br><span class="hljs-comment">// cnt[]存储以每个节点结尾的单词数量</span><br><span class="hljs-comment">// idx用于记录Trie中当前节点的数量</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>    cnt[p] ++ ;<br>&#125;<br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing143. 最大异或对</title>
    <link href="/2023/07/22/%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9/"/>
    <url>/2023/07/22/%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="acwing143.-最大异或对">AcWing143. 最大异或对</h1><blockquote><p>原题链接：<a href="https://www.acwing.com/problem/content/145/">143. 最大异或对 - AcWing题库</a></p></blockquote><h2 id="一题目">一、题目</h2><p>在给定的 <span class="math inline">\(N\)</span> 个整数 <span class="math inline">\(A_1，A_2……A_N\)</span> 中选出两个进行 <span class="math inline">\(xor\)</span>（异或）运算，得到的结果最大是多少？</p><h4 id="输入格式">输入格式</h4><p>第一行输入一个整数 <span class="math inline">\(N\)</span>。</p><p>第二行输入 <span class="math inline">\(N\)</span> 个整数 <span class="math inline">\(A_1～A_N\)</span>。</p><h4 id="输出格式">输出格式</h4><p>输出一个整数表示答案。</p><h4 id="数据范围">数据范围</h4><p><span class="math inline">\(1≤N≤10^5\)</span> <span class="math inline">\(0≤A_i&lt;2^{31}\)</span></p><h4 id="输入样例">输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs input">3<br>1 2 3<br></code></pre></td></tr></table></figure><h4 id="输出样例">输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">3<br></code></pre></td></tr></table></figure><h2 id="二分析">二、分析</h2><p><strong>异或运算（同 <span class="math inline">\(0\)</span> 异 <span class="math inline">\(1\)</span>）：</strong>异或运算是一种二进制位运算，也称异或操作。如果两个对应的二进制位相同，则异或的结果为 <span class="math inline">\(0\)</span>；如果两个对应的二进制位不同，则异或结果为 <span class="math inline">\(1\)</span>。</p><p><img src="https://s1.ax1x.com/2023/07/23/pCq6yp8.png" style="zoom: 50%;"></p><p><strong>性质：</strong>对于一个二进制数，如果要找到与其异或最大的数，则使高位与要找的数的对应位异或为 <span class="math inline">\(1\)</span>。</p><p><img src="https://s1.ax1x.com/2023/07/23/pCq661S.png" style="zoom:50%;"></p><hr><p><strong>暴力做法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-comment">// 枚举第一个数</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) <span class="hljs-comment">// 枚举第二个数</span><br>        ans = <span class="hljs-built_in">max</span>(ans, a[i] ^ a[j]);<br>&#125;<br></code></pre></td></tr></table></figure><p>第 <span class="math inline">\(2\)</span> 层<code>for</code>循环的含义：从<code>a[i+1]</code>到<code>a[n-1]</code>找到一个和<code>a[i]</code>异或最大的一个结果，内层循环的时间复杂度为 <span class="math inline">\(O(n)\)</span>，总体时间复杂度为 <span class="math inline">\(O(n^2)\)</span>。可以通过Trie树对内层<code>for</code>循环优化。</p><p><strong>Trie树优化：</strong></p><p>由题意知，每个整数都可以用 <span class="math inline">\(31\)</span> 位的二进制串来表示，再结合上面提到的异或的性质，则可以把每个整数表示成Trie树中的一个序列（其中，每个序列的存储是从高位开始的，即离根节点越近的结点在二进制数中的位数越高）。</p><p>当我们求解与<code>a[i]</code>异或的最大值时，需要遍历我们构造的Trie树，每次尽可能的往和当前位不同的位（图中紫色路径）上走。当走到叶节点的时候，我们就找到与当前<code>a[i]</code>异或最大的结果了。</p><p>此时，内层查找代码的时间复杂度为 <span class="math inline">\(O(31)\)</span>，则总体时间复杂度为 <span class="math inline">\(O(n)\)</span>。</p><h2 id="三题解">三、题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">3100010</span>;<br><span class="hljs-type">int</span> n, a[N], son[M][<span class="hljs-number">2</span>], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-type">int</span> u = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-type">int</span> u = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (son[p][!u])<br>        &#123;<br>            res += <span class="hljs-number">1</span> &lt;&lt; i;<br>            p = son[p][!u];<br>        &#125;<br>        <span class="hljs-keyword">else</span> p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>        <span class="hljs-built_in">insert</span>(a[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> max_res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        max_res = <span class="hljs-built_in">max</span>(max_res, <span class="hljs-built_in">search</span>(a[i]));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, max_res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie树</tag>
      
      <tag>异或</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用conda命令</title>
    <link href="/2023/07/17/%E5%B8%B8%E7%94%A8conda%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/07/17/%E5%B8%B8%E7%94%A8conda%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="常用conda命令">常用Conda命令</h1><p><strong>查看已经创建的虚拟环境：</strong><code>conda env list</code></p><p><strong>创建conda虚拟环境：</strong><code>conda create -n your_env_name python=x.x</code></p><p><strong>激活conda虚拟环境：</strong><code>conda activate your_env_name</code></p><p><strong>删除conda虚拟环境：</strong><code>conda remove -n your_env_name --all</code></p><hr><p><strong>查看当前conda环境中安装了哪些包：</strong><code>conda list</code></p><p><strong>在虚拟环境中安装包：</strong><code>conda install -n your_env_name [package]</code></p><p><strong>检查更新当前conda：</strong><code>conda update conda</code></p>]]></content>
    
    
    <categories>
      
      <category>Conda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>conda命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing3717. 整数序列</title>
    <link href="/2023/07/16/%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <url>/2023/07/16/%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="acwing3717.-整数序列">AcWing3717. 整数序列</h1><blockquote><p>原题链接：<a href="https://www.acwing.com/problem/content/description/3720/">3717. 整数序列 - AcWing题库</a></p></blockquote><h2 id="一题目">一、题目</h2><p>很多整数可以由一段连续的<strong>正整数</strong>序列（至少两个数）相加而成，比如<span class="math inline">\(25=3+4+5+6+7=12+13\)</span>。</p><p>输入一个整数 <span class="math inline">\(N\)</span>，输出 <span class="math inline">\(N\)</span> 的全部正整数序列，如果没有则输出 <code>NONE</code>。</p><p><strong>输入格式</strong></p><p>一个整数 <span class="math inline">\(N\)</span>。</p><p><strong>输出格式</strong></p><p>每行输出一个满足条件的整数序列。</p><p>序列内部元素从小到大排序。</p><p>优先输出首项更小的序列。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(2≤N≤10^7\)</span></p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs input">25<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs output">3 4 5 6 7<br>12 13<br></code></pre></td></tr></table></figure><h2 id="二分析">二、分析</h2><h4 id="二分">二分</h4><p>枚举首项，通过二分找到尾项，使满足 <span class="math inline">\(n=\frac{(a+b)n}{2}\)</span>。其中，<span class="math inline">\(a\)</span> 为首项、<span class="math inline">\(b\)</span> 为尾项。</p><h4 id="数学知识推公式-分解质因数">数学知识（推公式 + 分解质因数）</h4><blockquote><p>等差数列前 <span class="math inline">\(n\)</span> 项和公式：$ S_n=na_1+{d} $</p></blockquote><p>设答案序列首项为 <span class="math inline">\(a\)</span>，共 <span class="math inline">\(k\)</span> 项，且有题目知公差为 <span class="math inline">\(1\)</span>，则所求的序列为 <span class="math inline">\(a\)</span>、<span class="math inline">\(a+1\)</span>、<span class="math inline">\(a+2\)</span>、<span class="math inline">\(…\)</span>、<span class="math inline">\(a+k-1\)</span>。</p><p>由等差数列前 <span class="math inline">\(n\)</span> 项和公式得：<span class="math inline">\(n=ka+{\frac{k\left( k-1 \right)}{2}}\)</span></p><p>从而得到：<span class="math inline">\(2n=k(2a+k-1)\)</span></p><p>设 <span class="math inline">\(x=k\)</span>、<span class="math inline">\(y=2a+k-1\)</span>，则 <span class="math inline">\(xy=2n\)</span> 。</p><p><strong>推条件：</strong>由题意知，首项 <span class="math inline">\(a&gt;0\)</span> ，则 <span class="math inline">\(2a=y-x+1&gt;0\)</span>，<span class="math inline">\(y&gt;x-1\)</span>，即 <span class="math inline">\(x\leqslant y\)</span>；由于首项 <span class="math inline">\(a\)</span> 为整数，且首项 <span class="math inline">\(a\)</span> 满足 <span class="math inline">\(2a=y-x+1&gt;0\)</span>，即 <span class="math inline">\(a=\frac{y-x+1}{2}\)</span>，即 <span class="math inline">\(y-x+1\)</span> 为偶数。</p><p><strong>推范围：</strong>由于 <span class="math inline">\(x\leqslant y\)</span>，且 <span class="math inline">\(xy=2n\)</span>，得 <span class="math inline">\(x\leqslant {\frac{2n}{x}}\)</span>，即 <span class="math inline">\(x\leqslant \sqrt{2n}\)</span>。</p><p><strong>输出要求：</strong>由于要先输出尽可能小的数，已知 <span class="math inline">\(a\)</span> 为首项，因此只要让 <span class="math inline">\(a\)</span> 由小往大遍历即可。由上面的等式可以得到 <span class="math inline">\(2a = \frac{2n}{k}-(k+1)\)</span>，可见 <span class="math inline">\(a\)</span> 会随 <span class="math inline">\(k\)</span> 的增加而减少 ，且由于 <span class="math inline">\(x=k\)</span>，因此只要让 <span class="math inline">\(x\)</span> 由大往小遍历即可。</p><h2 id="三题解">三、题解</h2><p>不知道为什么二分的时间会更长</p><p><img src="https://s1.ax1x.com/2023/07/17/pCI4oi6.png" alt="image-20230716234258894" style="zoom:80%;"></p><blockquote><p><strong>ChatGPT是这样说的：</strong></p><p>首先，我们来看一下它们的时间复杂度：</p><ul><li>二分方法的代码：在平均情况下，二分查找算法的时间复杂度为O(logn)。由于在每次迭代中，我们将搜索范围减半，因此该代码的时间复杂度可以近似为O(logn)。</li><li>暴力枚举的代码：在该代码中，我们使用了一个循环来逐步增加序列的长度，直到找到满足条件的序列。因此，该代码的时间复杂度为O(n)。</li></ul><p>现在我们来解释为什么"二分方法的代码"的运行时间较长：</p><ol type="1"><li>二分方法的代码中使用了二分查找来寻找满足条件的序列的起始和结束位置。这需要多次进行二分查找操作，每次查找都需要将搜索范围减半。虽然二分查找的时间复杂度较低，但它在一次迭代中进行了多次查找。</li><li>每次二分查找中，我们还需要进行一些复杂的乘法和除法运算来计算中间位置的值。这些运算需要一定的时间。</li><li>此外，二分方法的代码还包含了一些其他的操作，如条件判断和循环控制。这些操作也会增加代码的运行时间。</li></ol><p>因此，相对于暴力枚举的代码，二分方法的代码需要进行更多的操作和计算，导致其运行时间更长。在特定情况下，例如当输入的n较大时，二分方法的代码的差距会更加明显。</p></blockquote><h4 id="方法一暴力枚举-on2">方法一：暴力枚举 <span class="math inline">\(O(n^2)\)</span></h4><p>没想到暴力也能过٩(๑&gt;◡&lt;๑)۶</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, j = i;<br>        <span class="hljs-keyword">while</span> (sum + j &lt; n) sum += j, j++;<br>        <span class="hljs-keyword">if</span> (sum + j == n) <br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt;= j; k++) <br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k); <br>            flag = <span class="hljs-literal">true</span>; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NONE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二二分">方法二：二分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; a &lt;= n / <span class="hljs-number">2</span>; a++)<br>    &#123;<br>        <span class="hljs-type">int</span> l = a + <span class="hljs-number">1</span>, r = n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) <br>        &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-comment">// 在后续计算中使用乘法会导致超出int的范围, 因此选择使用long long类型</span><br>            <span class="hljs-keyword">if</span> ((a + mid) * (mid - a + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &gt;= n) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((a + l) * (l - a + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> == n) <br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = a; k &lt;= l; k++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k); <br>            flag = <span class="hljs-literal">true</span>; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NONE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法三数学知识">方法三：数学知识</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span> * n); x &gt;= <span class="hljs-number">2</span>; x--)<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * n % x == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> y = <span class="hljs-number">2</span> * n / x;<br>            <span class="hljs-type">int</span> k = x;<br>            <span class="hljs-type">int</span> t = y - x + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = t / <span class="hljs-number">2</span>; i &lt; k; i++, j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, j);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NONE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>数学知识</tag>
      
      <tag>试除法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing3302. 表达式求值</title>
    <link href="/2023/07/12/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2023/07/12/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="acwing3302.-表达式求值">AcWing3302. 表达式求值</h1><blockquote><p><strong>原题链接：</strong><a href="https://www.acwing.com/problem/content/3305/">3302. 表达式求值 - AcWing题库</a></p></blockquote><h2 id="一题目">一、题目</h2><p>给定一个表达式，其中运算符仅包含 <code>+,-,*,/</code>（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p><p><strong>注意：</strong></p><ul><li>数据保证给定的表达式合法。</li><li>题目保证符号 <code>-</code> 只作为减号出现，不会作为负号出现，例如，<code>-1+2</code>,<code>(2+2)*(-(1+1)+2)</code> 之类表达式均不会出现。</li><li>题目保证表达式中所有数字均为正整数。</li><li>题目保证表达式在中间计算过程以及结果中，均不超过 <span class="math inline">\(2^{31}−1\)</span>。</li><li>题目中的整除是指向 00 取整，也就是说对于大于 00 的结果向下取整，例如 <span class="math inline">\(5/3=1\)</span>，对于小于 <span class="math inline">\(0\)</span> 的结果向上取整，例如 <span class="math inline">\(5/(1−4)=−1\)</span>。</li><li>C++和Java中的整除默认是向零取整；Python中的整除<code>//</code>默认向下取整，因此Python的<code>eval()</code>函数中的整除也是向下取整，在本题中不能直接使用。</li></ul><p><strong>输入格式</strong></p><p>共一行，为给定表达式。</p><p><strong>输出格式</strong></p><p>共一行，为表达式的结果。</p><p><strong>数据范围</strong></p><p>表达式的长度不超过 <span class="math inline">\(10^5\)</span>。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs input">(2+2)*(1+1)<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">8<br></code></pre></td></tr></table></figure><h2 id="二样例分析">二、样例分析</h2><p>题目中所给的表达式为<strong>中缀表达式</strong>，先将其转化为<strong>中缀表达式树</strong>（所有内部结点都是运算符、所有叶子结点都是数）：</p><p><img src="https://s1.ax1x.com/2023/07/16/pCInwKf.png" style="zoom:100%;"></p><p>中序遍历树得到的中缀表达式要加括号（保证运算符的优先级），即结果为 <span class="math inline">\((2+2)×(1+1)\)</span> 而非 <span class="math inline">\(2+2×1+1\)</span> ；后序遍历树得到的后缀表达式不需要加括号，即结果为 <span class="math inline">\(2\ 2+1\ 1+×\)</span> 。</p><p>可以通过<strong>递归</strong>的方式求解：</p><p><img src="https://s1.ax1x.com/2023/07/16/pCInBqS.png" style="zoom:100%;"></p><p><strong>中序遍历+栈：</strong></p><p><img src="https://s1.ax1x.com/2023/07/16/pCInrVg.png" style="zoom:100%;"></p><h2 id="三题解">三、题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span><span class="hljs-comment">// 哈希表</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>stack&lt;<span class="hljs-type">int</span>&gt; num;<span class="hljs-comment">// 存数字</span><br>stack&lt;<span class="hljs-type">char</span>&gt; op;<span class="hljs-comment">// 存运算符</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> b = num.<span class="hljs-built_in">top</span>(); num.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 取出第二个数字</span><br>    <span class="hljs-keyword">auto</span> a = num.<span class="hljs-built_in">top</span>(); num.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 取出第一个数字</span><br>    <span class="hljs-keyword">auto</span> c = op.<span class="hljs-built_in">top</span>(); op.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 取出运算符</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-comment">// 计算</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span>) x = a + b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>) x = a - b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;*&#x27;</span>) x = a * b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) x = a / b;<br>    num.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">// 将计算结果存入栈中</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; pr&#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>&#125;&#125;;<span class="hljs-comment">// 定义各个运算符的优先级, 数越大优先级越大</span><br>    string str;<br>    cin &gt;&gt; str;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> c = str[i];<span class="hljs-comment">// 存取当前字符</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))<span class="hljs-comment">// 如果当前字符是数字, 把当前的数字取出来</span><br>        &#123;<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[j]))<br>                x = x * <span class="hljs-number">10</span> + str[j++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            i = j - <span class="hljs-number">1</span>;<span class="hljs-comment">// 变化指针i的位置</span><br>            num.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">// 把数字放到栈里</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) op.<span class="hljs-built_in">push</span>(c);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-built_in">eval</span>();<span class="hljs-comment">// 把栈里面所有运算符从右往左操作一遍, 直到遇到 (</span><br>            op.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 弹出左括号</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 一般的运算符</span><br>        &#123;<br>            <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>() &amp;&amp; op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="hljs-built_in">top</span>()] &gt;= pr[c]) <span class="hljs-built_in">eval</span>();<span class="hljs-comment">// 运算符栈不为空, 且栈顶元素优先级高于当前元素, 循环操作高优先级运算符</span><br>            op.<span class="hljs-built_in">push</span>(c);<span class="hljs-comment">// 将当前运算符存入栈</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">eval</span>();<span class="hljs-comment">// 从右往左操作一遍运算符</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, num.<span class="hljs-built_in">top</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>表达式求值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列</title>
    <link href="/2023/07/09/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2023/07/09/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈与队列单调队列单调栈">栈与队列：单调队列、单调栈</h1><blockquote><p>使用<strong>数组</strong>模拟</p></blockquote><p><img src="https://s1.ax1x.com/2023/07/16/pC5OlxP.png" style="zoom:80%;"></p><h2 id="栈">1. 栈</h2><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// tt表示栈顶下标</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[++tt] = x;<br><br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt--;<br><br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><br><span class="hljs-comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列">2. 队列</h2><h3 id="普通队列">1. 普通队列</h3><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[++tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh++;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环队列">2. 循环队列</h3><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// hh 表示队头，tt表示队尾的后一个位置</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[tt++] = x;<br><span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh++;<br><span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh != tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调栈">3. 单调栈</h2><blockquote><p><strong>常见题型：</strong>给定一个序列，找到这个序列中每一个数左边离它最近的数的位置。</p></blockquote><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; <span class="hljs-built_in">check</span>(stk[tt], i)) tt -- ;<br>    stk[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列">4. 单调队列</h2><blockquote><p><strong>最经典的应用：</strong>求滑动窗口中的最大值或最小值</p></blockquote><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check_out</span>(q[hh])) hh ++ ;  <span class="hljs-comment">// 判断队头是否滑出窗口</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check</span>(q[tt], i)) tt -- ;<br>    q[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
      <tag>单调栈</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表与邻接表</title>
    <link href="/2023/07/08/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    <url>/2023/07/08/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表与邻接表树与图的存储">链表与邻接表：树与图的存储</h1><ul><li><p>使用<strong>数组</strong>模拟（静态链表）</p></li><li><p>使用<strong>指针</strong>+<strong>结构体</strong>模拟（动态链表、在笔试题中一般不会用）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    Node *next;<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(); <span class="hljs-comment">// 非常慢</span><br></code></pre></td></tr></table></figure><h2 id="使用数组模拟单链表">1. 使用数组模拟单链表</h2><p>在算法题中，使用最多的单链表是邻接表（n个链表）</p><h3 id="单链表与邻接表">1.1 单链表与邻接表</h3><p><strong>邻接表的用途：</strong>存储数与图</p><p>在单链表中，用<code>e[ ]</code>表示该结点的值，用<code>ne[ ]</code>表示该结点的下一结点的编号。</p><p><img src="https://s1.ax1x.com/2023/07/16/pC5OQ2t.png" style="zoom:80%;"></p><h3 id="单链表的优缺点单链表是只往后看的">1.2 单链表的优缺点（单链表是只往后看的）</h3><p><strong>优点：</strong>单链表可以用 <span class="math inline">\(O(1)\)</span> 的时间找到下一个结点的位置</p><p><strong>缺点：</strong>单链表不能用 <span class="math inline">\(O(1)\)</span> 的时间找到上一个结点的位置（只能从头开始遍历）</p><h3 id="模板">1.3 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx++;<br>&#125;<br><br><span class="hljs-comment">// 在链表第k个结点后面插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = ne[k], ne[k] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = ne[head];<br>&#125;<br><br><span class="hljs-comment">// 将下标是k的点后面的点删掉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k] = ne[ne[k]];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用数组模拟双链表">2. 使用数组模拟双链表</h2><p><strong>双链表的用途：</strong>优化某些问题</p><ul><li>双链表与单链表的区别在于：单链表只有一个方向，双链表是双向的</li></ul><h3 id="模板-1"><strong>模板</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//0是左端点，1是右端点</span><br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 在节点a的右边插入一个数x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    l[idx] = a, r[idx] = r[a];<br>    l[r[a]] = idx, r[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 删除节点a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    l[r[a]] = l[a];<br>    r[l[a]] = r[a];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单链表</tag>
      
      <tag>双链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间合并</title>
    <link href="/2023/07/04/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <url>/2023/07/04/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="区间合并">区间合并</h1><p><strong>应用场景：</strong>将 <span class="math inline">\(n\)</span> 个区间中，所有有交集的区间合并（假设两个区间只有端点相交的，那么他们也是可以合并的）。</p><p><img src="https://s1.ax1x.com/2023/07/15/pC5Qrvt.png" style="zoom:80%;"></p><p><strong>算法步骤：</strong></p><ol type="1"><li><p>按区间的左端点排序</p></li><li><p>扫描整个区间，把所有有交集的区间合并</p></li></ol><h2 id="模板">模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//区间按照做端点排序</span><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<span class="hljs-comment">// 定义+无穷和-无穷</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区间合并</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散化</title>
    <link href="/2023/07/04/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <url>/2023/07/04/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="离散化">离散化</h1><blockquote><p>特指整数的离散化、保序的离散化</p></blockquote><p><strong>序列特点：</strong>值域较大（<span class="math inline">\(0\)</span> ~ <span class="math inline">\(10^9\)</span>）、个数较少（可能只有<span class="math inline">\(10^5\)</span>个数）</p><p>有些题目可能要以这些序列的值为下标来做，因此需要把序列映射到从 <span class="math inline">\(0\)</span> 开始的连续的自然数。</p><p><img src="https://s1.ax1x.com/2023/07/15/pC5QM4J.png" style="zoom:80%;"></p><p><strong>离散化中常见的两个问题：</strong></p><ol type="1"><li><code>a[]</code>中可能有重复元素 -&gt; 去重</li><li>如何计算<code>x</code>离散化后的值 -&gt; 二分查找</li></ol><h2 id="模板">模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2023/07/04/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2023/07/04/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算">位运算</h1><p>常用的两种位运算的操作：求 <span class="math inline">\(n\)</span> 的第 <span class="math inline">\(k\)</span> 位数字和 <span class="math inline">\(n\)</span> 的最后一位</p><h2 id="n的二进制表示中第k位">1. n的二进制表示中第k位</h2><p><strong>思路：</strong></p><ol type="1"><li>先把第 <span class="math inline">\(k\)</span> 位移到最后一位，即<code>n &gt;&gt; k</code></li><li>看一下最低位是几，<code>x &amp; 1</code></li></ol><p>结合①和②，得到公式：<code>n &gt;&gt; k &amp; 1</code></p><blockquote><p>位移运算不会改变原数据的值，即<code>n &gt;&gt; k</code>前后<code>n</code>的值不变</p></blockquote><h2 id="n的二进制表示中最后一位">2. n的二进制表示中最后一位</h2><p><code>lowbit()</code>是树状数组的基本操作，<code>lowbit(x)</code>的作用是返回<code>x</code>的最后一位<code>1</code>。例如：如果二进制数<code>x = 1010</code>，则<code>lowbit(x)</code>返回的是<code>10</code>，即十进制数<code>2</code>；如果二进制数<code>x = 101000</code>，则<code>lowbit(x)</code>返回的是<code>1000</code>，即十进制数<code>8</code>。</p><p><strong>实现：</strong><code>lowbit(x) = x &amp; -x</code>。其中，<code>-x</code>是<code>x</code>的补码，即<code>x</code>取反加一</p><p><strong>应用：</strong>统计<code>x</code>的二进制表示中<code>1</code>的个数。每次把最后一位<code>1</code>减掉，当<code>x</code>的值为<code>0</code>时停止，统计循环次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求n的第k位数字: </span><br>n &gt;&gt; k &amp; <span class="hljs-number">1</span><br><span class="hljs-comment">// 返回n的最后一位1：</span><br><span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制的第k位</tag>
      
      <tag>lowbit( )</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针算法</title>
    <link href="/2023/07/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <url>/2023/07/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针算法">双指针算法</h1><ul><li><p><strong>第一类：</strong>指向的是<strong>两个序列</strong>，例如：归并排序中的双指针</p></li><li><p><strong>第二类：</strong>指向的是<strong>一个序列</strong>（常见），例如：快速排序的双指针</p></li></ul><h2 id="核心思想">1. 核心思想</h2><p>将下面的朴素算法的时间复杂度优化到 <span class="math inline">\(O(n)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        <span class="hljs-comment">// 操作</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么双指针算法的时间复杂度是 <span class="math inline">\(O(n)\)</span> ?</strong></p><p>双指针算法的时间复杂度为 <span class="math inline">\(O(n)\)</span> 的原因是，它通常在一个循环中使用两个指针进行迭代，而这两个指针相对于输入规模 <span class="math inline">\(n\)</span> 的数量级是线性的。</p><p>在双指针算法中，指针通常从输入序列的两端开始，然后向中间移动，根据特定的条件调整指针的位置。算法的终止条件可能是两个指针相遇或到达特定位置。</p><p>由于每次迭代中，指针的移动都是以固定的步长进行的，而且指针从两个方向同时移动，因此整个算法的执行时间与输入规模 <span class="math inline">\(n\)</span> 成线性关系。换句话说，算法的运行时间随着输入规模的增加而线性增长。</p><p>需要注意的是，虽然双指针算法的时间复杂度通常是 <span class="math inline">\(O(n)\)</span>，但也可以有特殊情况下的变体，其时间复杂度可能是 <span class="math inline">\(O(n^2)\)</span> 或其他不同的复杂度。这取决于算法的具体实现和问题的特定要求。但是，一般而言，双指针算法的时间复杂度是线性的，即 <span class="math inline">\(O(n)\)</span>。</p></blockquote><h2 id="例子">2. 例子</h2><p><strong>题目要求：</strong></p><p>输入一个字符串，其中包含多个单词，每个单词用空格隔开，输出每个单词。（假定字符串开始时没有空格，且每个单词之间只有一个空格）</p><p><strong>分析：</strong></p><p><img src="https://s1.ax1x.com/2023/07/15/pC5M5nK.png" style="zoom:80%;"></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">1000</span>];<br>    <span class="hljs-built_in">gets</span>(str);<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; str[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++;<br>        <span class="hljs-comment">// 这道题的具体逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; k++) cout &lt;&lt; str[k];<br>        cout &lt;&lt; endl;<br>        i = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板">3. 模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j++ ;<br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br><span class="hljs-comment">// 常见问题分类：</span><br>    <span class="hljs-comment">// (1) 对于一个序列，用两个指针维护一段区间</span><br>    <span class="hljs-comment">// (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></code></pre></td></tr></table></figure><p><strong>总结（双指针算法的实现思路）</strong></p><ol type="1"><li>写出题目对应的暴力解法（时间复杂度为 <span class="math inline">\(O(n^2)\)</span>），寻找两个循环索引 <span class="math inline">\(i、j\)</span> 之间的单调关系</li><li>如果有单调关系的话，利用其单调关系，把状态数量由 <span class="math inline">\(n^2\)</span> 变成 <span class="math inline">\(n\)</span>，从而把时间复杂度由 <span class="math inline">\(O(n^2)\)</span> 变成 <span class="math inline">\(O(n)\)</span></li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2023/07/02/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2023/07/02/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和与差分">前缀和与差分</h1><p><strong>差分：</strong><span class="math inline">\(a_1\)</span>、<span class="math inline">\(a_2\)</span>、<span class="math inline">\(a_3\)</span>、……、<span class="math inline">\(a_n\)</span> （下标从 <span class="math inline">\(1\)</span> 开始）</p><p><strong>前缀和：</strong><span class="math inline">\(S_1\)</span>、<span class="math inline">\(S_2\)</span>、<span class="math inline">\(S_3\)</span>、……、<span class="math inline">\(S_n\)</span> 其中，<span class="math inline">\(S_i=a_1+a_2+a_3+...+a_i\)</span> （下标从 <span class="math inline">\(1\)</span> 开始，定义 <span class="math inline">\(S_0=0\)</span>）</p><h2 id="前缀和">1. 前缀和</h2><h4 id="涉及到的两个问题">1. 涉及到的两个问题</h4><ol type="1"><li><p>如何求 <span class="math inline">\(S_i\)</span> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一维前缀和的初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<span class="hljs-comment">// 前缀和的初始化</span><br><span class="hljs-comment">// 二维前缀和的初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        s[i][j] = a[i][j] + s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li><li><p>前缀和数组 <span class="math inline">\(S_i\)</span> 的作用：快速求出原数组中的一段数的和。</p><blockquote><p><strong>前缀和数组作用的例子：</strong>假设题目要求求出数组中<code>[l, r]</code>的数的和（区间和的计算）</p><ul><li>如果没有前缀和数组，则需循环一遍求解，此时时间复杂度为 <span class="math inline">\(O(n)\)</span></li><li>如果有前缀和数组，则可直接计算得出 <span class="math inline">\(S_r-S_{l-1}\)</span>，此时时间复杂度为 <span class="math inline">\(O(1)\)</span></li></ul></blockquote></li></ol><h4 id="为什么前缀和的下标从1开始">2. 为什么前缀和的下标从1开始</h4><p><strong>主要是处理边界问题：</strong>当需要求数组<code>[1, t]</code>的数的和的时候，可以直接通过 <span class="math inline">\(S_t-S_0\)</span>，不用考虑边界问题。同时，这也是把 <span class="math inline">\(S_0\)</span> 定义为 <span class="math inline">\(0\)</span> 的原因。虽然该问题可以直接以 <span class="math inline">\(S_t\)</span> 为答案，但是为了统一计算公式，选择这种计算方法。</p><h3 id="一维前缀和">1.1 一维前缀和</h3><p>作用：<strong>快速求出某一区间的和</strong></p><p><strong>原数组：</strong><span class="math inline">\(a_i\)</span></p><p><strong>前缀和数组：</strong><span class="math inline">\(S_i\)</span></p><p><strong>区间和计算公式：</strong><span class="math inline">\([l,\ r]=S_r-S_{l-1}\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="二维前缀和">1.2 二维前缀和</h3><p>与一维前缀和类似，二维前缀和是为了<strong>快速求出某一子矩阵的和</strong></p><p><strong>原数组：</strong><span class="math inline">\(a_{ij}\)</span></p><p><strong>前缀和数组：</strong><span class="math inline">\(S_{ij}\)</span></p><p><strong>子矩阵和计算公式：</strong> <span class="math display">\[\left[ \begin{matrix}    \left( x_1, y_1 \right)&amp;        \left( x_1, y_2 \right)\\    \left( x_2, y_1 \right)&amp;        \left( x_2, y_2 \right)\\\end{matrix} \right] =S_{x_2y_2}-S_{x_1-1 y_2}-S_{x_2\,\,y_1-1}+S_{x_1-1 y_1-1}\]</span> <img src="https://s1.ax1x.com/2023/07/15/pC5Mapn.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">S[i, j] =  <span class="hljs-comment">// 第i行j列格子左上部分所有元素的和</span><br><span class="hljs-comment">// 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/15/pC5Mw60.png" style="zoom:80%;"></p><h2 id="差分">2. 差分</h2><h4 id="差分的作用">1. 差分的作用</h4><p>对于数组 <span class="math inline">\(a_i\ (i=1,2,3,…,n)\)</span>，其前缀和为 <span class="math inline">\(s_i\ (i = 1,2,3,…,n)\)</span>。<span class="math inline">\(a_i\)</span> 为 <span class="math inline">\(s_i\)</span> 的差分，满足 <span class="math inline">\(a_i\ = s_i \ - \ s_{i-1}\)</span>，即： <span class="math display">\[a_1 = s_1\\a_2 = s_2-s_1\\a_3 = s_3-s_2\\a_4 = s_4-s_3\\……\\a_n = s_n-s_{n-1}\]</span> <strong>作用：</strong>对于前缀和数组 <span class="math inline">\(s_i\)</span> ，如果需要使其从第 <span class="math inline">\(l\)</span> 项开始到第 <span class="math inline">\(r\)</span> 项每项都增加一个常数 <span class="math inline">\(C\)</span> 。如果直接对前缀和数组 <span class="math inline">\(s_i\)</span> 操作的话，即对 <span class="math inline">\(s_i\ (i = l,l+1,…,r)\)</span> 每一项都增加一个常数 <span class="math inline">\(C\)</span>，程序的时间复杂度为 <span class="math inline">\(O(n)\)</span>；如果对差分数组 <span class="math inline">\(a_i\)</span> 操作的话，即使 <span class="math inline">\(a_l + C\)</span> 、<span class="math inline">\(a_{r+1} - C\)</span>，程序的时间复杂度为 <span class="math inline">\(O(1)\)</span>。</p><h3 id="一维差分">2.1 一维差分</h3><p><strong>作用：</strong>给一维数组的一段加上一个值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br></code></pre></td></tr></table></figure><blockquote><p><strong>过程：</strong></p><ol type="1"><li><p>定义前缀和数组，并输入初值（给 <span class="math inline">\(s_i\)</span> 赋初值）</p></li><li><p>根据前缀和数组的值，给差分数组赋初值（给 <span class="math inline">\(a_i\)</span> 赋值）</p><p>对于差分数组中的第 <span class="math inline">\(i\)</span> 个元素，采用插入的方式：对于区间<code>[i,i]</code>插入<code>s[i]</code>，即<code>a[i] + s[i]</code>、<code>a[i+1] - s[i]</code></p></li><li><p>根据差分数组，求出其前缀和即可</p></li></ol></blockquote><h3 id="二维差分">2.2 二维差分</h3><p><strong>作用：</strong>给二维数组数组的一个子矩阵加上一个值</p><p><img src="https://s1.ax1x.com/2023/07/15/pC5Ms7F.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></td></tr></table></figure><blockquote><p>过程同一维差分，只不过计算差分数组的方式不同</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度</title>
    <link href="/2023/07/01/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/2023/07/01/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度">高精度</h1><blockquote><p><code>A</code>和<code>B</code>的位数约为<span class="math inline">\(10^6\)</span>，即<code>len(A)</code>和<code>len(B)</code>的结果为<span class="math inline">\(10^6\)</span></p><p><code>a</code>的数值小于等于<span class="math inline">\(10^9\)</span>，即<code>a&lt;=10^9</code></p></blockquote><h2 id="大整数是如何表示的">1. 大整数是如何表示的</h2><p>用<code>int</code>肯定是不行的，一般把大整数存储在数组里，并且要存储的数的最低位要放在数组索引为<code>0</code>的位置，即倒序存储。</p><blockquote><p><strong>大整数存储要倒序的原因：</strong></p><p>在对大整数做运算时，很可能出现进位的情况。当正序存储且需要进位时，就需要把数组中的所有元素后移一位，腾出最高位的空间。但是这会大大提高程序运行的时间复杂度，因此选择使用倒序存储。</p></blockquote><p>大整数的运算是一个模拟人工加法/减法/乘法/除法的过程。</p><blockquote><p>通常以字符串的形式读入大整数，然后通过<code>for</code>循环遍历字符串中的每个元素，存储到<code>vector&lt;int&gt;</code>中。注意，在存储的时候，要将字符串中的字符元素转化为整型元素，即<code>a[i] - '\0'</code>.</p></blockquote><h2 id="两个比较大的整数相加ab">2. 两个比较大的整数相加<code>A+B</code></h2><h3 id="实现原理">2.1 实现原理</h3><p><img src="https://s1.ax1x.com/2023/07/14/pC4xFN4.png" style="zoom:100%;"></p><p><strong>串行进位加法器</strong>：从最低位开始计算，每一位的运算都是<span class="math inline">\(A_i+B_i+t\)</span>，其中<span class="math inline">\(A_i\)</span>是被加数的第<span class="math inline">\(i\)</span>位、<span class="math inline">\(B_i\)</span>是加数的第<span class="math inline">\(i\)</span>位、<span class="math inline">\(t\)</span>是上一位的进位。最初状态时，<span class="math inline">\(t\)</span>被赋初值<span class="math inline">\(0\)</span>，相当于向最低位的进位为<span class="math inline">\(0\)</span>。</p><h3 id="代码模板">2.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span><span class="hljs-comment">// 接收结果时, 可以使用auto类型</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    vector&lt;int&gt; C;</span><br><span class="hljs-comment">    int t = 0;</span><br><span class="hljs-comment">    for (int i = 0; i &lt; A.size() || i &lt; B.size(); i ++ )</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        if (i &lt; A.size()) t += A[i];</span><br><span class="hljs-comment">        if (i &lt; B.size()) t += B[i];</span><br><span class="hljs-comment">        C.push_back(t % 10);</span><br><span class="hljs-comment">        t /= 10;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    if (t) C.push_back(t);</span><br><span class="hljs-comment">    return C;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="两个比较大的整数相减a-b">3. 两个比较大的整数相减<code>A-B</code></h2><h3 id="实现原理-1">3.1 实现原理</h3><p><img src="https://s1.ax1x.com/2023/07/14/pC4xk4J.png" style="zoom:100%;"></p><p><strong>(1) 两步实现：</strong></p><ol type="1"><li><p>判断<code>A</code>和<code>B</code>的大小。如果<code>A&gt;=B</code>，直接算<code>A-B</code>；如果<code>A&lt;B</code>，计算<code>B-A</code>后加上负号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断是否有 A &gt;= B</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span>(A[i] != B[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<span class="hljs-comment">// A &gt; B</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// A = B</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算<code>A-B</code></p></li></ol><p><strong>(2) 对于每一位的计算：</strong>需要计算<span class="math inline">\(A_i-B_i-t\)</span>，其中<span class="math inline">\(A_i\)</span>是被减数的第<span class="math inline">\(i\)</span>位、<span class="math inline">\(B_i\)</span>是减数的第<span class="math inline">\(i\)</span>位、<span class="math inline">\(t\)</span>是上一位借位。最初状态时，<span class="math inline">\(t\)</span>被赋初值<span class="math inline">\(0\)</span>，相当于向最低位的借位为<span class="math inline">\(0\)</span>。如果其结果<code>&gt;=0</code>，则直接为该位的计算结果；如果其结果<code>&lt;0</code>，则说明该位不够减，应该向上一位借位，从而在结果上<code>+10</code>。<span class="math inline">\(t\)</span>根据借位与否，决定其之后的值是1还是0。</p><h3 id="代码模板-1">3.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 去掉前导0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一个大整数乘一个小整数aa">4. 一个大整数乘一个小整数<code>A*a</code></h2><h3 id="实现原理-2">4.1 实现原理</h3><p>对于每一位的计算：分别计算当前位于乘数的乘积。计算 <span class="math inline">\((A_i*b+t)\%10\)</span> 作为当前位的计算结果，<span class="math inline">\((A_i+b+t)/10\)</span> 作为当前位的进位，并赋值给 <span class="math inline">\(t\)</span>。其中，<span class="math inline">\(A\)</span> 是乘数（大整数）、<span class="math inline">\(b\)</span> 是小整数、<span class="math inline">\(t\)</span> 是上一位的进位。</p><h3 id="代码模板-2">4.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<span class="hljs-comment">// 当前位的计算结果</span><br>        t /= <span class="hljs-number">10</span>;<span class="hljs-comment">// 进位</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一个大整数除以一个小整数ab">5. 一个大整数除以一个小整数<code>A/b</code></h2><h3 id="实现原理-3">5.1 实现原理</h3><p>模拟<strong>人工除法</strong>的过程：定义被除数为 <span class="math inline">\(A\)</span>（大整数）、除数为 <span class="math inline">\(b\)</span>（小整数）、余数 <span class="math inline">\(r\)</span>（小整数），初始时 <span class="math inline">\(r\)</span> 的值定义的 <span class="math inline">\(0\)</span>。计算每一位的时候，<span class="math inline">\((r*10+A_i)/b\)</span> 作为当前位的商，<span class="math inline">\((r*10+A_i)\%b\)</span> 作为当前位的余数。</p><p>计算结束后，由于计算结果不满足倒序存储，因此需要调用<code>reverse(C.begin(), C.end())</code>反转存储结果，使结果满足倒序存储。</p><h3 id="代码模板-3">5.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度加法</tag>
      
      <tag>高精度减法</tag>
      
      <tag>高精度乘法</tag>
      
      <tag>高精度除法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2023/07/01/%E4%BA%8C%E5%88%86/"/>
    <url>/2023/07/01/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二分">二分</h1><p>二分的本质不是单调性。有单调性的题目一定可以二分，可以二分的题目不一定必须有单调性。</p><h2 id="整数二分">1. 整数二分</h2><p><img src="https://s1.ax1x.com/2023/07/14/pC4vynK.png" style="zoom:80%;"></p><h3 id="主要思想">1.1 主要思想</h3><p>在一个区间内部，使用二分的方法得到答案。每次选择答案所在的区间进行二分，且每次都能保证区间内有答案。对于有解的问题，二分得到的是正确答案；对于无解的题目，二分得到的是答案应该存在的位置。</p><h3 id="整数二分的实现过程">1.2 整数二分的实现过程</h3><ol type="1"><li>找一个中间值，即<code>mid = (l + r) / 2</code></li><li>（假设判断的是红色的性质）每次判断一下中间值是否满足性质，即<code>if(check(mid))</code><ul><li>情况一：<code>true</code><ul><li>说明<code>mid</code>满足该性质，因此<code>ans</code>所在区间为<code>[mid, r]</code></li><li>更新方式：<code>l = mid</code></li></ul></li><li>情况二：<code>false</code><ul><li>说明<code>mid</code>不满足该性质，因此<code>ans</code>所在区间为<code>[l, mid - 1]</code></li><li>更新方式：<code>r = mid - 1</code></li></ul></li></ul></li><li>（假设判断的是绿色的性质）每次判断一下中间值是否满足性质，即<code>if(check(mid))</code><ul><li>情况一：<code>true</code><ul><li>说明<code>mid</code>满足该性质，因此<code>ans</code>所在区间为<code>[l, mid]</code></li><li>更新方式：<code>r = mid</code></li></ul></li><li>情况二：<code>false</code><ul><li>说明<code>mid</code>不满足该性质，因此<code>ans</code>所在区间为<code>[mid + 1, r]</code></li><li>更新方式：<code>l = mid + 1</code></li></ul></li></ul></li></ol><blockquote><p><strong>中间值“是否+1”的问题</strong></p><p>如果<code>mid = (l + r) / 2</code>，当<code>l = r - 1</code>时，求得<code>mid</code>的值为<code>l</code>，倘若此时<code>check()</code>正好取得<code>true</code>，则会执行<code>l = mid</code>，即<code>l</code>更新后的值还是<code>l</code>，就会陷入死循环状态。</p></blockquote><h3 id="模板">1.3 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分">2. 浮点数二分</h2><h3 id="浮点数二分的实现过程">2.1 浮点数二分的实现过程</h3><p><img src="https://s1.ax1x.com/2023/07/14/pC4vrX6.png" style="zoom:80%;"></p><p>由于浮点数除法的结果仍然是浮点数，是保留精度的，其与整数除法的整除存在一定的差异。因此，浮点数二分不用考虑<strong>边界问题</strong>，其能够准确的把两个区间分为两部分。</p><h3 id="模板-1">2.2 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<span class="hljs-comment">// 注意是大-小, 或者直接用abs()函数取绝对值</span><br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>经验</strong>：如果题目要求保留4位小数，则<code>r-l</code>应该小于<code>1e-6</code>；如果题目要求保留5位小数，则<code>r-l</code>应该小于<code>1e-7</code>；如果题目要求保留6位小数，则<code>r-l</code>应该小于<code>1e-8</code>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整数二分</tag>
      
      <tag>浮点数二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2023/06/29/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/06/29/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序">归并排序</h1><h2 id="主要思想">1. 主要思想</h2><p>归并排序算法的主要思想：<strong>分治</strong></p><h2 id="归并排序的步骤">2. 归并排序的步骤</h2><ol type="1"><li><p>确定分界点</p><ul><li><p>以数组的中间位置为分界点，分为左右两部分。</p></li><li><p><code>mid = (l + r) / 2</code></p></li></ul></li><li><p>递归排序左右两部分</p><ul><li>递归左右两部分，对最小的单位进行排序</li></ul></li><li><p>归并——合二为一<strong>（重难点）</strong></p><ul><li>把两个有序的数组合并为一个有序的数组</li></ul></li></ol><ul><li><strong>时空复杂度：</strong><ul><li>时间复杂度：<span class="math inline">\(O(nlog_2n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ul></li></ul><h2 id="实现过程双指针算法">3. 实现过程（双指针算法）</h2><p><img src="https://s1.ax1x.com/2023/07/14/pC4vPfA.png"></p><blockquote><p>图片摘自：http://t.csdn.cn/RNb0o</p></blockquote><h2 id="模板">4. 模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前区间是否只有一个数或者没有数</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-comment">// 排序当前数组</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++] = q[j++];<br>    <span class="hljs-comment">// 处理某数组的元素全部排序完成，另一个数组中包含元素的情况</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];<br>    <span class="hljs-comment">// 把临时数组中排好序的内容转移到要排序的数组</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2023/06/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/06/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序">快速排序</h1><h2 id="主要思想">1. 主要思想</h2><p>快速排序算法的主要思想：<strong>分治</strong></p><h2 id="快速排序的步骤">2. 快速排序的步骤</h2><ol type="1"><li>确定分界点<code>x</code><ul><li>确定一个分界点，用于将数组划分为两个子数组</li><li>常用方式：取边界（<code>q[l]</code>或<code>q[r]</code>）、取中间值（<code>q[(l+r)/2]</code>）、取区间内随机一个数</li></ul></li><li>调整区间<strong>（重难点）</strong><ul><li>根据分界点，把区间分为两部分，使得左边区间的数都<code>&lt;=x</code>，右边区间的数都<code>&gt;=x</code></li></ul></li><li>递归处理左右两段区间</li></ol><p><img src="https://s1.ax1x.com/2023/07/14/pC4LFqe.png"></p><h2 id="如何调整区间">3. 如何调整区间</h2><h3 id="方法一暴力法思想简单占用额外空间">方法一：暴力法（思想简单、占用额外空间）</h3><ul><li><strong>基本思想：</strong><ul><li><p>首先，开两个额外的数组<code>a[]</code>、<code>b[]</code>。</p></li><li><p>然后，扫描<code>q[l] ~ q[r]</code>的每一个数。如果<code>q[i]&lt;=x</code>，则把其插入到数组<code>a[]</code>中；如果<code>q[i]&gt;x</code>，则把其插入到数组<code>b[]</code>中。</p></li><li><p>最后，先遍历数组<code>a[]</code>，再遍历数组<code>b[]</code>，把数组中的数依次存储到数组<code>q[]</code>中。</p></li></ul></li><li><strong>时空复杂度：</strong><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ul></li></ul><h3 id="方法二双指针法优美而简洁">方法二：双指针法（优美而简洁）</h3><blockquote><p><strong>要点：</strong>在任何时刻，<code>i</code>指针左边所有的数都一定<code>&lt;=x</code>，<code>j</code>指针右边的数都一定<code>&gt;=x</code>。</p><p><strong>原因：</strong>当<code>i</code>指针在遍历时，如果当前数满足<code>&lt;x</code>的条件时，则<code>i</code>会指向下一个数；如果当前数不满足<code>&lt;x</code>的条件时，<code>i</code>指针会等待<code>j</code>指针找到一个<code>&gt;=x</code>的数与之交换，从而使得当前数也满足<code>&lt;=x</code>的条件。最终，<code>i</code>指针左侧所有的数都一定<code>&lt;=x</code>。对于<code>j</code>指针，同理。</p></blockquote><ul><li><p><strong>基本思想：</strong></p><ul><li><p>定义两个指针<code>i</code>和<code>j</code>，分别指向要排序的数组<code>q</code>的两端</p><p><img src="https://s1.ax1x.com/2023/07/14/pC4LirD.png" alt="pC4LirD.png"></p></li><li><p>两个指针分别往中间走，即<code>i++</code>和<code>j--</code>。</p><ul><li><p>首先，移动<code>i</code>指针。当<code>i</code>指向的值满足<code>q[i]&lt;x</code>时，<code>i</code>做自增运算，即<code>i++</code>；否则，<code>i</code>指针停止移动。</p></li><li><p>然后，移动<code>j</code>指针。当<code>j</code>指向的值满足<code>q[j]&gt;x</code>时，<code>j</code>做自减运算，即<code>j--</code>；否则，<code>j</code>指针停止移动。</p><p><img src="https://s1.ax1x.com/2023/07/14/pC4LPKO.png" alt="pC4LPKO.png"></p></li></ul></li><li><p>做完上述指针移动操作后，<code>i</code>指针左边所有的值都满足<code>q[]&lt;x</code>，<code>j</code>指针右边所有的值都满足<code>q[]&gt;x</code>，但此时<code>q[i]&gt;=x</code>且<code>q[j]&lt;=x</code>。为满足要求（调整区间），需要通过交换<code>i</code>和<code>j</code>指向的值，使得<code>i</code>指向的值满足<code>q[i]&lt;=x</code>、<code>j</code>指向的值满足<code>q[j]&gt;=x</code>，从而使程序能够继续运行。</p><p><img src="https://s1.ax1x.com/2023/07/14/pC4LmGt.png" alt="pC4LmGt.png"></p></li><li><p>当<code>i&gt;j</code>时，说明已经得到了两端调整后的区间（此时，<code>i</code>指针左边的值都满足小于等于x，<code>j</code>指针右边的值都满足大于等于x）</p><p><img src="https://s1.ax1x.com/2023/07/14/pC4L9xK.png" alt="pC4L9xK.png"></p></li></ul></li><li><p><strong>时空复杂度：</strong></p></li><li><p>时间复杂度：<span class="math inline">\(O(nlog_2n)\)</span></p></li><li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li></ul><h2 id="模板">4. 模板</h2><h3 id="模板-1">(1) 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 模板1☆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前要排序的子数组中的元素个数是否&lt;=1</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 调整区间</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<span class="hljs-comment">// 这里尽量用 j</span><br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-comment">// 模板2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前要排序的子数组中的元素个数是否&lt;=1</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 调整区间</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关于边界问题">(2) 关于边界问题</h3><p><strong>正确代码1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<span class="hljs-comment">// 或者x = q[(l+r)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/14/pC4LAVH.png"></p><p><strong>错误代码1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[r];<span class="hljs-comment">// 或者x = q[(l+r)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/14/pC4LEad.png"></p><p><strong>正确代码2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[r];<span class="hljs-comment">// 或者x = q[(l+r+1)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/14/pC4LVIA.png"></p><p><strong>错误代码2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<span class="hljs-comment">// 或者x = q[(l+r+1)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/14/pC4LePI.png"></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
