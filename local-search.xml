<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AcWing842. 排列数字</title>
    <link href="/2023/08/14/%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97/"/>
    <url>/2023/08/14/%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="acwing842.-排列数字">AcWing842. 排列数字</h1><blockquote><p><strong>原题链接：</strong><a href="https://www.acwing.com/problem/content/description/844/">842. 排列数字 - AcWing题库</a></p></blockquote><h2 id="一题目">一、题目</h2><p>给定一个整数 <span class="math inline">\(n\)</span>，将数字 <span class="math inline">\(1∼n\)</span> 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><h4 id="输入格式">输入格式</h4><p>共一行，包含一个整数 <span class="math inline">\(n\)</span>。</p><h4 id="输出格式">输出格式</h4><p>按字典序输出所有排列方案，每个方案占一行。</p><h4 id="数据范围">数据范围</h4><p><span class="math inline">\(1≤n≤7\)</span></p><h4 id="输入样例">输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs input">3<br></code></pre></td></tr></table></figure><h4 id="输出样例">输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs output">1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1<br></code></pre></td></tr></table></figure><h2 id="二分析">二、分析</h2><h3 id="通过数组记录取值">2.1 通过数组记录取值</h3><p>由题意可知，本题可以通过 DFS 的方式实现。通过逐层记录每层递归的情况，到达最底层后输出每层的数字即可。然后恢复现场进行回溯，最后能够将所有情况一一列举（如下图所示）。</p><p><img src="https://s1.ax1x.com/2023/08/15/pPQYlhn.png" style="zoom: 33%;"></p><p>在该方法中，使用的记录方法是通过<code>bool</code>数组。当数组的指项为<code>true</code>时，表示该项数值已被使用，从而不重复使用这个数值；反之，则表明该数值能够使用。</p><p>在DFS中，通过层层递归实现对每个位置的数字的填补。在进入递归前，需要将该层用到的数字的标志位（即<code>bool</code>数组的指定项）置为<code>true</code>，表示当前数字已经被使用；在递归到达最底层的时候（即所有位置都填补完后），输出填补的结果；在递归回溯的时候，将本层已经使用的数字的标志位置为<code>false</code>，表示当前数字已经释放。</p><h3 id="通过位运算优化">2.2 通过位运算优化</h3><p>通过上述方法实现的程序需要一个额外的<code>bool</code>数组，用于记录数字是否被使用，存在浪费空间的缺点。因此，可以通过一个二进制数的方式表示每位的数字是否已经使用，作为参数在递归的每层之间传递。</p><p>该数字初始状态时，为 <span class="math inline">\(0\)</span>，即全部未使用。在DFS中，通过<code>state &gt;&gt; i &amp; 1</code>判断第<code>i</code>位是否已经使用。在调用下层递归的时候，给<code>state</code>传递的值为<code>state | 1 &lt;&lt; i</code>，表示将<code>state</code>的第<code>i</code>位置为<code>1</code>，即该位表示的数已经使用。</p><h2 id="三题解">三、题解</h2><p><strong>代码1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, a[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x == n) <br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">if</span> (!st[i])<br>    &#123;<br>    st[i] = <span class="hljs-literal">true</span>;<br>    a[x] = i;<br>    <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>);<br>    st[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> state)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x == n) <br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">if</span> (!(state &gt;&gt; i &amp; <span class="hljs-number">1</span>))<br>        &#123;<br>            a[x] = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, state | <span class="hljs-number">1</span> &lt;&lt; i);<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL的使用技巧</title>
    <link href="/2023/08/13/C-STL%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/08/13/C-STL%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="c-stl的使用技巧">C++ STL的使用技巧</h1><h2 id="一变长数组-vector">一、变长数组 <code>vector</code></h2><p>使用时需要包含头文件<code>vector</code>。</p><p><code>vector</code>支持比较运算，其比较方式是按照字典序进行比较。假设比较两个<code>vector</code>分别为<code>a</code>和<code>b</code>，从第 0 个元素开始比较，如果<code>a</code>的元素大于同等位置的<code>b</code>的元素，则<code>a &gt; b</code>；如果<code>a</code>的元素小于同等位置的<code>b</code>的元素，则<code>a &lt; b</code>；如果两者相等，则继续比较下一位，如果最终一个<code>vector</code>比完后还是相等，则长度大的<code>vector</code>大。</p><p><strong><code>vector</code>的初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方式一：直接定义一个vector</span><br>vector&lt;<span class="hljs-type">int</span>&gt; a;<br><span class="hljs-comment">// 方式二：定义长度的vector</span><br><span class="hljs-type">int</span> n = <span class="hljs-number">100</span>；<br>vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">b</span>(n);<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-comment">// 方式三：定义长度并初始化的vector</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">// 定义一个长度为10的vector, 初始化为3</span><br><span class="hljs-comment">// 方式四：定义一个vevtor数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p><strong><code>vector</code>支持的函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">a.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 返回vector中的元素个数    时间复杂度:O(1)</span><br>a.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">// 返回vector是否为空(空:true;不空:false)    时间复杂度:O(1)</span><br>a.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">// 清空vector</span><br>a.<span class="hljs-built_in">front</span>();<span class="hljs-comment">// 返回vector的第一个数</span><br>a.<span class="hljs-built_in">back</span>();<span class="hljs-comment">// 返回vector的最后一个数</span><br>a.<span class="hljs-built_in">push_back</span>();<span class="hljs-comment">// 向vector的最后插入一个数</span><br>a.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 删除vector的最后一个数</span><br>a.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">// 迭代器, vector的第0个数, 即 a[0]</span><br>a.<span class="hljs-built_in">end</span>();<span class="hljs-comment">// 迭代器, vector的最后一个数的后面一个数, 即 a[a.size()]</span><br>[]<span class="hljs-comment">// 支持随机寻址</span><br><span class="hljs-comment">// 例子</span><br>vector&lt;<span class="hljs-type">int</span>&gt; a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter = a.<span class="hljs-built_in">begin</span>();<br>cout &lt;&lt; *iter;<span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure><p><strong><code>vector</code>的遍历：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 遍历方式一：以数组的方式遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><span class="hljs-comment">// 遍历方式二：通过迭代器遍历(可以看做是指针)</span><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator i = a.<span class="hljs-built_in">begin</span>(); i != a.<span class="hljs-built_in">end</span>(); i++) cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br><span class="hljs-comment">// 遍历方式三</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><blockquote><p>系统为某一程序分配空间的时候，所需的时间与空间的大小无关，而是与分配的次数有关。例如，程序申请长度为 100 的数组和申请长度为 1000 的数组所需的时间是相同的；而程序申请一个长度为 1000 的数组和申请 100 个长度为 10 的数组所需的时间是 100 倍的关系。</p><p>所以，变长数组<code>vector</code>要尽量减少申请空间的次数。</p></blockquote><h2 id="二pair">二、<code>pair</code></h2><p><code>pair</code>可以存储一个二元组，其中前后两个变量的类型可以任意。</p><p><code>pair</code>支持比较运算。在比较时，以first为第一关键字、以second为第二关键字（字典序）进行比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-comment">// pair的定义</span><br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; a;<br>pair&lt;<span class="hljs-type">int</span>, string&gt; b;<br>pair&lt;<span class="hljs-type">int</span>, string&gt; c;<br><span class="hljs-comment">// 构造一个pair (初始化)</span><br>b = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;str&quot;</span>);<br>c = &#123;<span class="hljs-number">20</span>, <span class="hljs-string">&quot;abc&quot;</span>&#125;;<br><span class="hljs-comment">// 取pair中的元素</span><br>a.<span class="hljs-built_in">first</span>();<span class="hljs-comment">// pair中的第一个元素</span><br>a.<span class="hljs-built_in">second</span>();<span class="hljs-comment">// pair中的第二个元素</span><br><span class="hljs-comment">// pair支持嵌套</span><br>pair&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">int</span>, string&gt;&gt; p;<span class="hljs-comment">// 实现用pair存储三个相关联的属性</span><br></code></pre></td></tr></table></figure><h2 id="三字符串-string">三、字符串 <code>string</code></h2><p><strong><code>string</code>的初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方式一：直接赋值</span><br>string str1 = <span class="hljs-string">&quot;test01&quot;</span>;<br><span class="hljs-comment">// 方式二：拷贝赋值</span><br><span class="hljs-comment">// 以length为长度的ch拷贝，即length个ch</span><br><span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;s&#x27;</span>)</span></span>;<span class="hljs-comment">// sssss</span><br><span class="hljs-comment">// 方式三：括号法</span><br><span class="hljs-function">string <span class="hljs-title">str3</span><span class="hljs-params">(<span class="hljs-string">&quot;This is const char!&quot;</span>)</span></span>;<br><span class="hljs-comment">// 方式四：字串</span><br><span class="hljs-comment">// string(string &amp;str, size_type index, size_type length)</span><br><span class="hljs-comment">// 以index为索引开始的字串，长度为length</span><br><span class="hljs-function">string <span class="hljs-title">str4</span><span class="hljs-params">(str3, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>)</span></span>;<span class="hljs-comment">// const ch</span><br></code></pre></td></tr></table></figure><p><strong><code>string</code>支持的函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 返回字符串的长度</span><br>s.<span class="hljs-built_in">length</span>();<span class="hljs-comment">// 返回字符串的长度</span><br>s.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">// 返回字符串是否为空</span><br>s.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">// 清空字符串</span><br><span class="hljs-comment">// substr()函数</span><br>s.<span class="hljs-built_in">substr</span>(起始下标, (字串长度));<span class="hljs-comment">// 返回字串</span><br><span class="hljs-comment">// 当第二个参数的长度超过主串长度时, 字串就会取到最后一个字母为止</span><br><span class="hljs-comment">// 当第二个参数省略的时候, 字串就会从起始下标开始取到结尾</span><br><span class="hljs-comment">// c_str()函数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, s.<span class="hljs-built_in">c_str</span>());<span class="hljs-comment">// 返回字符串所在字符数组的起始地址</span><br></code></pre></td></tr></table></figure><h2 id="四队列-queue">四、队列 <code>queue</code></h2><p><strong><code>queue</code>的初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br></code></pre></td></tr></table></figure><p><strong><code>queue</code>支持的函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">q.<span class="hljs-built_in">size</span>()<span class="hljs-comment">// 队列的长度</span><br>q.<span class="hljs-built_in">empty</span>()<span class="hljs-comment">// 队列是否为空</span><br>q.<span class="hljs-built_in">push</span>()  <span class="hljs-comment">// 向队尾插入一个元素</span><br>q.<span class="hljs-built_in">front</span>()  <span class="hljs-comment">// 返回队头元素</span><br>q.<span class="hljs-built_in">back</span>()  <span class="hljs-comment">// 返回队尾元素</span><br>q.<span class="hljs-built_in">pop</span>()  <span class="hljs-comment">// 弹出队头元素</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>队列中不存在<code>clear</code>函数，要想清空队列，可以使用代码<code>q = queue&lt;int&gt; ();</code></p></blockquote><h2 id="五优先队列-priority_queue">五、优先队列 <code>priority_queue</code></h2><p>优先队列<code>priority_queue</code>实际上是一个堆，默认为大根堆。</p><p><strong><code>priority_queue</code>支持的函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>&gt; heap;<br>heap.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 返回堆的大小</span><br>heap.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">// 判断堆是否为空</span><br>heap.<span class="hljs-built_in">push</span>();  <span class="hljs-comment">// 插入一个元素</span><br>heap.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">// 返回堆顶元素</span><br>heap.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 弹出堆顶元素</span><br></code></pre></td></tr></table></figure><p><strong>定义成小根堆的方式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方式一：插入时，按照负数插入 (技巧)</span><br>heap.<span class="hljs-built_in">push</span>(-x);<br><span class="hljs-comment">// 方式二：加入参数</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br></code></pre></td></tr></table></figure><h2 id="六栈-stack">六、栈 <code>stack</code></h2><p><strong><code>stack</code>支持的函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt; s;<br>s.<span class="hljs-built_in">size</span>()<span class="hljs-comment">// 返回栈的大小</span><br>s.<span class="hljs-built_in">empty</span>()<span class="hljs-comment">// 判断栈是否为空</span><br>s.<span class="hljs-built_in">push</span>()  <span class="hljs-comment">// 向栈顶插入一个元素</span><br>s.<span class="hljs-built_in">top</span>()  <span class="hljs-comment">// 返回栈顶元素</span><br>s.<span class="hljs-built_in">pop</span>()<span class="hljs-comment">// 弹出栈顶元素</span><br></code></pre></td></tr></table></figure><h2 id="七双端队列-deque">七、双端队列 <code>deque</code></h2><p><code>deque</code>相当于加强版的<code>vector</code>，功能相比于<code>vector</code>更多。</p><p><strong>头文件：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong><code>deque</code>支持的函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 返回双端队列的大小</span><br>q.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">// 判断双端队列是否为空</span><br>q.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">// 清空双端队列</span><br>q.<span class="hljs-built_in">front</span>();<span class="hljs-comment">// 返回第一个元素</span><br>q.<span class="hljs-built_in">back</span>();<span class="hljs-comment">// 返回最后一个元素</span><br>q.<span class="hljs-built_in">push_back</span>();<span class="hljs-comment">// 向队尾插入一个元素</span><br>q.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 在队尾弹出一个元素</span><br>q.<span class="hljs-built_in">push_front</span>();<span class="hljs-comment">// 向队首插入一个元素</span><br>q.<span class="hljs-built_in">pop_front</span>();<span class="hljs-comment">// 在队首弹出一个元素</span><br>q.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">// 支持迭代器 begin()</span><br>q.<span class="hljs-built_in">end</span>();<span class="hljs-comment">// 支持迭代器 end()</span><br>[]<span class="hljs-comment">// 支持随机寻址</span><br></code></pre></td></tr></table></figure><h2 id="八set-map-multiset-multimap">八、<code>set, map, multiset, multimap</code></h2><p><code>set, map, multiset, multimap</code>，基于平衡二叉树（红黑树），动态维护<strong>有序序列</strong>，增删改查的时间复杂度为 <span class="math inline">\(O(log_2n)\)</span> 。</p><p><strong>都能支持的操作：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">size</span>();<span class="hljs-comment">// 返回元素个数</span><br><span class="hljs-built_in">empty</span>();<span class="hljs-comment">// 判断是否为空</span><br><span class="hljs-built_in">clear</span>();<span class="hljs-comment">// 清空</span><br><span class="hljs-built_in">begin</span>();<span class="hljs-comment">// 迭代器begin()</span><br><span class="hljs-built_in">end</span>();<span class="hljs-comment">// 迭代器end()</span><br>迭代器是 ++, -- <span class="hljs-comment">// 返回有序序列的前驱和后继，时间复杂度 O(logn)</span><br></code></pre></td></tr></table></figure><h3 id="setmultiset">8.1 <code>set</code>/<code>multiset</code></h3><p><code>set</code>中不能存在重复元素（集合的性质）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span><span class="hljs-comment">// 头文件</span></span><br><span class="hljs-comment">/**********定义set**********/</span><br>set&lt;<span class="hljs-type">int</span>&gt; S;<br>multiset&lt;<span class="hljs-type">int</span>&gt; MS;<br><span class="hljs-comment">/**********支持的函数**********/</span><br>s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 返回元素个数    时间复杂度为O(1)</span><br>s.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">// 判断set是否为空    时间复杂度为O(1)</span><br>s.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">// 清空set</span><br>s.<span class="hljs-built_in">insert</span>();<span class="hljs-comment">// 插入一个数    时间复杂度为O(n)</span><br>s.<span class="hljs-built_in">find</span>();<span class="hljs-comment">// 查找一个数, 如果不存在的话, 返回迭代器end()</span><br>s.<span class="hljs-built_in">count</span>();<span class="hljs-comment">// 返回某一个数的个数</span><br>s.<span class="hljs-built_in">erase</span>();<br><span class="hljs-comment">// (1) 输入是一个数x，删除所有x(共k个x)   时间复杂度为O(k + logn)   </span><br><span class="hljs-comment">// (2) 输入一个迭代器，删除这个迭代器</span><br><span class="hljs-comment">/**********核心的函数**********/</span><br>s.<span class="hljs-built_in">lower_bound</span>(x);<span class="hljs-comment">// 返回大于等于x的最小的数的迭代器</span><br>s.<span class="hljs-built_in">upper_bound</span>(x);<span class="hljs-comment">// 返回大于x的最小的数的迭代器</span><br><span class="hljs-comment">// 如果不存在的话, 返回end()</span><br></code></pre></td></tr></table></figure><h3 id="mapmultimap">8.2 <code>map</code>/<code>multimap</code></h3><p><code>map</code>存储的是一个映射。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span><span class="hljs-comment">// 头文件</span></span><br><span class="hljs-comment">/**********定义map**********/</span><br>map&lt;string, <span class="hljs-type">int</span>&gt; a;<br><span class="hljs-comment">/**********支持的函数**********/</span><br>a.<span class="hljs-built_in">insert</span>();  <span class="hljs-comment">// 插入的数是一个pair</span><br>a.<span class="hljs-built_in">erase</span>();  <span class="hljs-comment">// (常用)输入的参数是pair或者迭代器</span><br>a.<span class="hljs-built_in">find</span>();<br>[]  <span class="hljs-comment">// 注意multimap不支持此操作时间复杂度是 O(logn)</span><br><span class="hljs-comment">// a[&quot;abc&quot;] = 1;</span><br><span class="hljs-comment">// cout &lt;&lt; a[&quot;abc&quot;] &lt;&lt; endl;// 1</span><br>a.<span class="hljs-built_in">lower_bound</span>();<span class="hljs-comment">// 返回大于等于x的最小的数的迭代器</span><br>a.<span class="hljs-built_in">upper_bound</span>();<span class="hljs-comment">// 返回大于x的最小的数的迭代器</span><br></code></pre></td></tr></table></figure><h3 id="哈希表-unordered_set-unordered_map-unordered_multiset-unordered_multimap">8.3 哈希表 <code>unordered_set, unordered_map, unordered_multiset, unordered_multimap</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span><span class="hljs-comment">// 头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span><span class="hljs-comment">// 头文件</span></span><br><span class="hljs-comment">// 和上面类似，增删改查的时间复杂度是 O(1)</span><br><span class="hljs-comment">// 不支持 lower_bound()/upper_bound(), 迭代器的++，--  (因为是无序的)</span><br></code></pre></td></tr></table></figure><h2 id="九压位-bitset">九、压位 <code>bitset</code></h2><p>假设程序需要要开一个长度为 <span class="math inline">\(1024\)</span> 的<code>bool</code>数组，由于一个<code>bool</code>类型占 <span class="math inline">\(1B\)</span>，因此需要使用 <span class="math inline">\(1024B\)</span> 。</p><p><code>bitset</code>就可以使用位来存储<code>bool</code>变量，每个字节存储八个，在这种情况下，只需要 <span class="math inline">\(128B\)</span> 就可以存储 <span class="math inline">\(1024\)</span> 个<code>bool</code>变量（占用的空间是C++中布尔数组的 <span class="math inline">\(\frac{1}{8}\)</span>）。</p><blockquote><p><strong>所适用的情况：</strong></p><p>假设题目要求要存储一个 <span class="math inline">\(10000×10000\)</span> 的布尔矩阵，此时若用<code>bool</code>变量存储的话，所用的空间为 <span class="math inline">\(100M\)</span>。如果使用<code>bitset</code>来存储的话，所用空间可以减少到 <span class="math inline">\(12M\)</span>。</p><p>如果此时题目要求最大空间为 <span class="math inline">\(64M\)</span>，则只能选用第二种方法。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**********定义bitset**********/</span><br>bitset&lt;10000&gt; s;<br><span class="hljs-comment">/**********支持的操作**********/</span><br>~, &amp;, |, ^<span class="hljs-comment">// 取反、与、或、异或</span><br>&gt;&gt;, &lt;&lt;<span class="hljs-comment">// 移位操作</span><br>==, !=<br>[]<span class="hljs-comment">// 支持随机存取</span><br><span class="hljs-comment">/**********支持的函数**********/</span><br>s.<span class="hljs-built_in">count</span>();<span class="hljs-comment">// 返回有多少个1</span><br>s.<span class="hljs-built_in">any</span>();<span class="hljs-comment">// 判断是否至少有一个1</span><br>s.<span class="hljs-built_in">none</span>();<span class="hljs-comment">// 判断是否全为0</span><br>s.<span class="hljs-built_in">set</span>();  <span class="hljs-comment">// 把所有位置成1</span><br>s.<span class="hljs-built_in">set</span>(k, v);<span class="hljs-comment">// 将第k位变成v</span><br>s.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">// 把所有位变成0</span><br>s.<span class="hljs-built_in">flip</span>();<span class="hljs-comment">// 等价于~</span><br>s.<span class="hljs-built_in">flip</span>(k);<span class="hljs-comment">// 把第k位取反</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>vector</tag>
      
      <tag>pair</tag>
      
      <tag>string</tag>
      
      <tag>queue</tag>
      
      <tag>priority_queue</tag>
      
      <tag>stack</tag>
      
      <tag>deque</tag>
      
      <tag>set</tag>
      
      <tag>map</tag>
      
      <tag>multiset</tag>
      
      <tag>multimap</tag>
      
      <tag>unordered_set</tag>
      
      <tag>unordered_map</tag>
      
      <tag>unordered_multiset</tag>
      
      <tag>unordered_multimap</tag>
      
      <tag>bitset</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hash表</title>
    <link href="/2023/08/10/Hash%E8%A1%A8/"/>
    <url>/2023/08/10/Hash%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="hash表">Hash表</h1><h2 id="一hash表的存储结构">一、Hash表的存储结构</h2><p>一般来说，Hash表的存储结构可以分为两大类，分别为 <strong>开放寻址法</strong> 和 <strong>拉链法</strong> 。</p><p><strong>Hash表的作用：</strong>通过哈希函数将键映射到唯一的索引位置，实现高效的数据查找和插入。</p><p><strong>哈希冲突</strong>指不同的键经过哈希函数后映射到了相同的索引位置，这种情况下需要通过冲突解决方法来处理，常见的解决冲突的方法包括拉链法（Chaining）和开放地址法（Open Addressing）等。</p><p>在算法题中，对于哈希表的操作一般只有 <strong>添加</strong> 和 <strong>删除</strong> 两个操作，不会出现删除操作。</p><blockquote><p><strong>与离散化的区别：</strong>离散化可以看作Hash表的一个特殊情况，因为离散化通常是保序的。</p></blockquote><h3 id="拉链法简单">1.1 拉链法（简单）</h3><p>在拉链法中，通过一个一维数组存储所有的哈希值。通过拉链法实现的哈希表是一种期望算法，虽然在每个槽上都会拉一个链，但是在平均情况下，每一条链的长度可以看成比较短常数。因此，在一般情况下，哈希表的时间复杂度可以看做 <span class="math inline">\(O(1)\)</span> 。</p><p>在执行 <strong>添加</strong> 操作时，先通过哈希函数<code>h(x)</code>求出<code>x</code>对应的哈希值，找到该哈希值对应的槽，将<code>x</code>添加到对应的链上（其中，链是单链表）。</p><p>在执行 <strong>查找</strong> 操作时，先通过哈希函数<code>h(x)</code>求出<code>x</code>对应的哈希值，找到该哈希值对应的槽，遍历一下该槽对应的单链表中是否存在<code>x</code>即可。</p><p>在执行 <strong>删除</strong> 操作时，同样通过哈希函数<code>h(x)</code>找到对应的槽，查找对应的值删除。但此处的删除并不是真正意义上的删除，而是对相应的节点打上一个标记，表示该结点已删除（例如，开一个<code>bool</code>变量，标记其是否删除）。</p><p><img src="https://s1.ax1x.com/2023/08/15/pPQNXpn.png" style="zoom:40%;"></p><blockquote><p>感觉其命名为 <strong>挂灯笼法</strong> 更形象。</p></blockquote><p><strong>注意：</strong>一般来说，在哈希表中，数组长度（取模的数）要求为质数，且该数要离 <span class="math inline">\(2\)</span> 的整数次幂尽可能的远。因为通过这种方法取的数组长度冲突的概率是最小的（通过数学的方法可以证明）。例如，想要取数组的长度为 <span class="math inline">\(10^5\)</span> ，那么可以找一个比数组稍大的且满足上述条件的数，在程序中可以使用这段代码检索这个数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">100000</span>; ; i++)<br>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j * j &lt;= i; j++)<br>        <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>)<br>        &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (flag)<br>    &#123;<br>        cout &lt;&lt; i &lt;&lt; endl;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>模板如下：</strong></p><p><img src="https://s1.ax1x.com/2023/08/15/pPQNLfs.png" alt="image-20230811163108664" style="zoom: 50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><br><span class="hljs-comment">// 向哈希表中插入一个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<span class="hljs-comment">// x % n 的值可能为负数, 因此通过 +n 再取模的方式避免为负数</span><br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 在哈希表中查询某个数是否存在</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])  <span class="hljs-comment">// h[]使用memset()初始化为 -1</span><br>        <span class="hljs-keyword">if</span> (e[i] == x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="开放寻址法">1.2 开放寻址法</h3><p>与拉链法不同，开放寻址法所使用的数据结构只有一个一维数组，但是一维数组的长度要为题目中数据长度的 <span class="math inline">\(2\)</span> ~ <span class="math inline">\(3\)</span> 倍。假设题目中输入了 <span class="math inline">\(10^5\)</span> 个数，那么数组的长度应该为 <span class="math inline">\(2×10^5\)</span> ~ <span class="math inline">\(3×10^5\)</span> 。</p><p>在执行 <strong>添加</strong> 操作时，先通过哈希函数<code>h(x)</code>求出<code>x</code>的哈希值<code>k</code>，根据哈希值<code>k</code>在一维数组中找到相应的位置。如果当前位置有值，则让哈希值<code>k</code>自增，查找下一个位置，直到查找到空位置将<code>x</code>存入为止。</p><p>在执行 <strong>查找</strong> 操作时，先通过哈希函数<code>h(x)</code>求出<code>x</code>的哈希值<code>k</code>，根据哈希值<code>k</code>在一维数组中找到相应的位置。如果当前位置有值，且当前位置的值不等于<code>x</code>，则让哈希值<code>k</code>自增，查找下一个位置，直到查找到<code>x</code>或者遇到空位置为止。</p><p>在执行 <strong>删除</strong> 操作时，先通过哈希函数<code>h(x)</code>求出<code>x</code>的哈希值<code>k</code>，根据哈希值<code>k</code>在一维数组中找到相应的位置。通过查找的方式找到要删除的值，然后将其赋值为无值的状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> null = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> h);<span class="hljs-comment">// 需要添加头文件 cstring</span><br></code></pre></td></tr></table></figure><blockquote><p><strong><code>memset()</code>函数：</strong></p><p><code>memset()</code>函数是按照字节进行赋值的。由于上面提到的<code>h</code>数组是<code>int</code>类型的，因此<code>int</code>类型的 <span class="math inline">\(4\)</span> 个字节都被赋值为<code>0x3f</code>即<code>0x3f3f3f3f</code>。</p><p><strong>常用的几个赋值：</strong></p><p><code>memset()</code>赋值为 <span class="math inline">\(0\)</span>，<span class="math inline">\(0\)</span> 的二进制表示为 <span class="math inline">\(00000000\)</span>，在赋值的时候，<span class="math inline">\(4\)</span>个字节全为 <span class="math inline">\(0\)</span>，因此最终赋值为 <span class="math inline">\(0\)</span>。</p><p><code>memset()</code>赋值为 <span class="math inline">\(-1\)</span>，<span class="math inline">\(-1\)</span> 的二进制表示为 <span class="math inline">\(11111111\)</span>，在赋值的时候， <span class="math inline">\(4\)</span> 个字节全为 <span class="math inline">\(-1\)</span>，因此最终赋值为 <span class="math inline">\(-1\)</span>。</p></blockquote><p><strong>模板如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N];<br><br><span class="hljs-comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = (x % N + N) % N;<br>    <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<br>    &#123;<br>        t ++ ;<br>        <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二字符串哈希方式">二、字符串哈希方式</h2><p>对于一些字符串相关的问题，不一定要用<code>KMP</code>来做，也可以用字符串哈希来做。</p><p><strong>作用：</strong>判断字符串中的两个字串是否相同，即判断两个字符串的哈希值是否相同。</p><p><strong>字符串哈希的求法：</strong>将字符串看成<code>P</code>进制数（根据经验，<code>P</code>取 <span class="math inline">\(131\)</span> 或 <span class="math inline">\(13331\)</span> 时，出现冲突的概率非常低），按照进制转换的方法，将该<code>P</code>进制数转化为 <span class="math inline">\(10\)</span> 进制数。由于转化后的数比较大，因此可以通过取模运算，对计算结果做取模处理（<code>mod Q</code>），这样就可以把任何一个字符串映射为 <span class="math inline">\(0\)</span> ~ <span class="math inline">\(Q\)</span> 之间的数（根据经验，<code>Q</code>取 <span class="math inline">\(2^{64}\)</span> 时出现冲突的概率比较低）。</p><p><strong>计算简化：</strong>因为<code>Q</code>取的为 <span class="math inline">\(2^{64}\)</span>，即对 <span class="math inline">\(2^{64}\)</span> 取模。在这里，可以直接使用<code>unsigned long long</code>存储所有的哈希值，此时不需要取模了，因为可以使用溢出来代替取模。</p><p><strong>两个假设：</strong></p><p>假设字符串的哈希值不为 <span class="math inline">\(0\)</span>。因为当字符串的哈希值为 <span class="math inline">\(0\)</span> 的时候，出现冲突的概率较高。例如，假设<code>A</code>的哈希值为 <span class="math inline">\(0\)</span>，那么<code>AA</code>的哈希值也为 <span class="math inline">\(0\)</span>，<code>AAA</code>的哈希值也为 <span class="math inline">\(0\)</span>，很大概率出现冲突。</p><p>假设字符串哈希中不存在冲突。根据经验，<code>P</code>取 <span class="math inline">\(131\)</span> 或 <span class="math inline">\(13331\)</span> 且<code>Q</code>取 <span class="math inline">\(2^{64}\)</span> 时，出现冲突的概率非常低。</p><hr><p>在使用字符串哈希处理字符串问题时，通常先计算出字符串的前缀哈希，即求出每一个前缀字串的哈希值，存储在<code>h</code>数组中。在解决实际问题时，通过字符串的前缀哈希求出字符串的哈希，进而进行字符串的相关操作。字符串的前缀哈希求法如下： <span class="math display">\[从\ l\ 到\ R\ 的哈希值:\\h[R] - h[L-1]×p^{R-L+1}\]</span> <img src="https://s1.ax1x.com/2023/08/15/pPQNqYj.png" style="zoom:70%;"></p><p><strong>模板如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低</span><br><span class="hljs-comment">// 小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><br><span class="hljs-comment">// 初始化</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;<span class="hljs-comment">// 供②处使用</span><br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<span class="hljs-comment">// ②</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hash表</tag>
      
      <tag>字符串哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2023/08/04/%E5%A0%86/"/>
    <url>/2023/08/04/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆">堆</h1><h2 id="一实现的堆要支持的操作">一、实现的堆要支持的操作</h2><ol type="1"><li>向集合中插入一个数</li><li>求集合当中的最小值</li><li>删除最小值</li><li>删除任意一个元素</li><li>修改任意一个元素</li></ol><blockquote><p>在手写堆实现的操作中，前三个操作STL中的堆也可以直接实现，但是后两种操作无法直接实现。</p></blockquote><h2 id="二堆的基本结构及存储">二、堆的基本结构及存储</h2><p>手动实现堆中，堆的数据结构是一个完全二叉树。</p><blockquote><p><strong>小根堆：</strong>任意节点的值都小于或等于它的子节点的值，这保证了根节点的值最小。</p><p><strong>大根堆：</strong>任意节点的值都大于或等于它的子节点的值，这保证了根节点的值最大。</p></blockquote><p>堆的存储：</p><p>使用一个一维数组来存储（常用此方法存储完全二叉树）。其中，1号点是根节点，<code>x</code>的左儿子是<code>2x</code>，<code>x</code>的右儿子是<code>2x+1</code>。</p><p><img src="https://s1.ax1x.com/2023/08/05/pPAee3D.png" style="zoom:80%;"></p><p><strong>如何建立一个堆？</strong></p><ol type="1"><li><p>通过插入的方式建堆。这种方法时间复杂度较高，为 <span class="math inline">\(O(nlog_{2}n)\)</span>。</p></li><li><p>通过下面的代码建堆，其时间复杂度为 <span class="math inline">\(O(n)\)</span>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;h[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i--) <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么这种方法的时间复杂度为 <span class="math inline">\(O(n)\)</span> ?</strong></p><p><img src="https://s1.ax1x.com/2023/08/05/pPAeKud.png" style="zoom:80%;"></p><p>由上图可得，执行<code>down()</code>操作的次数为： <span class="math display">\[S={\frac{n}{4}\times 1+\frac{n}{8}\times 2+\frac{n}{16}\times 3+\frac{n}{32}\times 4+···}\\=n \sum_{i=1}^{\infty} {\frac{i}{2^{i+1}}}\]</span></p><p><span class="math display">\[s={\frac{1}{2^2}+\frac{2}{2^3}+\frac{3}{2^4}+\frac{4}{2^5}+···}\]</span></p><p><span class="math display">\[2s={\frac{1}{2}}+{\frac{2}{2^2}}+{\frac{3}{2^3}}+{\frac{4}{2^4}}+···\]</span></p><p><span class="math display">\[s=2s-s={\frac{1}{2}}+{\frac{1}{2^2}}+{\frac{1}{2^3}}+{\frac{1}{2^4}}+···\\=1-\left({\frac{1}{2}} \right) ^n&lt;1\]</span></p><p>易知，该表达式和等差数列与等比数列乘积的前 <span class="math inline">\(n\)</span> 项和有关，且 <span class="math inline">\(s&lt;1\)</span>，故 <span class="math inline">\(S&lt;n\)</span>。</p><p>所以，通过此方法建堆时，时间复杂度最坏为 <span class="math inline">\(O(n)\)</span>。</p></blockquote></li></ol><h2 id="三两个基本操作">三、两个基本操作</h2><p>要实现的五个操作都可以通过下面的两种基本操作实现，即<code>down(x)</code>操作和<code>up(x)</code>操作。这两种操作都与树的高度有关，因此时间复杂度为 <span class="math inline">\(O(log_{2}n)\)</span>。</p><p><img src="https://s1.ax1x.com/2023/08/05/pPAewbn.png" style="zoom:80%;"></p><h3 id="downx操作">3.1 <code>down(x)</code>操作</h3><p><code>down(x)</code>是把一个结点往下移。对于更新后的堆，可能存在不满足父节点的值小于等于子节点的情况。因此，需要使用<code>down(x)</code>操作将父节点与子节点交换（每次选取更新后的节点及其左右子节点，比较其大小，选择子节点中最小的数与当前更新的节点交换），从而实现新的小根堆。</p><p><img src="https://s1.ax1x.com/2023/08/05/pPAeBEq.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><span class="hljs-comment">// x为下标</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(u != t)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[u], h[t]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="upx操作">3.2 <code>up(x)</code>操作</h3><p><code>up(x)</code>是把一个结点往上移。对于更新后的堆，可能存在不满足子节点的值大于等于父节点的情况。因此，需要使用<code>up(x)</code>操作将子节点与父节点交换（每次选取更新后的节点及其父节点和兄弟节点，比较其大小，选择最小的数作为当前子树的根），从而实现新的小根堆。</p><p><img src="https://s1.ax1x.com/2023/08/05/pPAeyCT.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(u / <span class="hljs-number">2</span> &amp;&amp; h[u / <span class="hljs-number">2</span>] &gt; h[u])<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(u, u / <span class="hljs-number">2</span>);<br>        u /= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用两个基本操作表示5种操作">3.3 使用两个基本操作表示5种操作</h3><ol type="1"><li><p>向集合中插入一个数</p><p>堆的插入操作，是在存储堆的一维数组的最后一个位置插入这个数，即<code>heap[++size] = x</code>。此时，当前堆中已经插入了数<code>x</code>，但有可能不满足小顶堆的特点。因此，还需要通过两种基本操作对堆进行维护操作。由于是在堆的最后一个位置插入的，因此只需要通过<code>up(size)</code>就可以维护小顶堆。</p><p><img src="https://s1.ax1x.com/2023/08/05/pPAec2F.png" style="zoom:80%;"></p></li><li><p>求集合当中的最小值</p><p>由于堆是小顶堆，因此集合中的最小的元素即为当前堆的根节点，即<code>heap[1]</code>。</p></li><li><p>删除最小值</p><p>堆的删除操作，是将存储堆的一维数组的最后一个位置的数覆盖到堆的根节点，然后将该一维数组的最后一个结点删除，即<code>heap[1] = heap[size--];</code>。此时，当前堆中已经插入了数<code>x</code>，但有可能不满足小顶堆的特点。因此，还需要通过两种基本操作对堆进行维护操作。由于堆的根节点发生了变化，因此只需要通过<code>down(1)</code>就可以维护小顶堆。</p><p><img src="https://s1.ax1x.com/2023/08/05/pPAe4V1.png" style="zoom:80%;"></p></li><li><p>删除任意一个元素</p><p>在小顶堆中删除任意一个元素和删除最小值的实现方式类似。将存储堆的一维数组的最后一个位置的数覆盖到要删除的位置，同时让一维数组的大小减一，即<code>heap[k] = heap[size--]</code>。此时，已经实现了删除操作，但需要使用两种基本操作对堆进行维护。由于删除的位置任意，删除位置的当前值与原来值相比可能有三种情况，即变大、变小和相等。其中，对于相等的情况，不需要对堆进行维护；对于变大的情况，则需要通过<code>down(k)</code>操作对堆进行维护；对于变小的情况，则需要通过<code>up(k)</code>操作对堆进行维护。由于他们之间是互斥的关系，因此可以在删除操作完成后对堆进行维护时，通过<code>down(k);up(k);</code>操作对堆进行维护。此时，除了相等的情况外，<code>down(k)</code>操作和<code>up(k)</code>操作仅执行一个。</p><p><img src="https://s1.ax1x.com/2023/08/05/pPAeI56.png" style="zoom:80%;"></p></li><li><p>修改任意一个元素</p><p>在小顶堆中修改任意一个元素和删除任意一个元素类似。假设要修改第<code>k</code>个位置的数为<code>x</code>，则只需要执行<code>heap[k] = x</code>，然后通过两种基本操作维护小顶堆即可。同样也是三种情况，同样也可以简化为<code>down(k);up(k);</code>操作。</p><p><img src="https://s1.ax1x.com/2023/08/05/pPAe78O.png" style="zoom:80%;"></p></li></ol><h2 id="四模板">四、模板</h2><p>一般的堆用到的只是简单的<code>down()</code>和<code>up()</code>操作，下面是较为复杂的堆的实现，其中添加了复杂的交换操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-type">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>    <span class="hljs-built_in">swap</span>(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, t);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// O(n)建堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing240. 食物链</title>
    <link href="/2023/07/25/%E9%A3%9F%E7%89%A9%E9%93%BE/"/>
    <url>/2023/07/25/%E9%A3%9F%E7%89%A9%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="acwing240.-食物链">AcWing240. 食物链</h1><blockquote><p>原题链接：<a href="https://www.acwing.com/problem/content/description/242/">240. 食物链 - AcWing题库</a></p></blockquote><h2 id="一题目">一、题目</h2><p>动物王国中有三类动物 <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>，这三类动物的食物链构成了有趣的环形。</p><p><span class="math inline">\(A\)</span> 吃 <span class="math inline">\(B\)</span>，<span class="math inline">\(B\)</span> 吃 <span class="math inline">\(C\)</span>，<span class="math inline">\(C\)</span> 吃 <span class="math inline">\(A\)</span>。</p><p>现有 <span class="math inline">\(N\)</span> 个动物，以 <span class="math inline">\(1∼N\)</span> 编号。</p><p>每个动物都是 <span class="math inline">\(A,B,C\)</span> 中的一种，但是我们并不知道它到底是哪一种。</p><p>有人用两种说法对这 <span class="math inline">\(N\)</span> 个动物所构成的食物链关系进行描述：</p><p>第一种说法是 <code>1 X Y</code>，表示 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是同类。</p><p>第二种说法是 <code>2 X Y</code>，表示 <span class="math inline">\(X\)</span> 吃 <span class="math inline">\(Y\)</span>。</p><p>此人对 <span class="math inline">\(N\)</span> 个动物，用上述两种说法，一句接一句地说出 <span class="math inline">\(K\)</span> 句话，这 <span class="math inline">\(K\)</span> 句话有的是真的，有的是假的。</p><p>当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ol type="1"><li>当前的话与前面的某些真的话冲突，就是假话；</li><li>当前的话中 <span class="math inline">\(X\)</span> 或 <span class="math inline">\(Y\)</span> 比 <span class="math inline">\(N\)</span> 大，就是假话；</li><li>当前的话表示 <span class="math inline">\(X\)</span> 吃 <span class="math inline">\(X\)</span>，就是假话。</li></ol><p>你的任务是根据给定的 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(K\)</span> 句话，输出假话的总数。</p><h4 id="输入格式">输入格式</h4><p>第一行是两个整数 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(K\)</span>，以一个空格分隔。</p><p>以下 <span class="math inline">\(K\)</span> 行每行是三个正整数 <span class="math inline">\(D\)</span>，<span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span>，两数之间用一个空格隔开，其中 <span class="math inline">\(D\)</span> 表示说法的种类。</p><p>若 <span class="math inline">\(D=1\)</span>，则表示 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是同类。</p><p>若 <span class="math inline">\(D=2\)</span>，则表示 <span class="math inline">\(X\)</span> 吃 <span class="math inline">\(Y\)</span>。</p><h4 id="输出格式">输出格式</h4><p>只有一个整数，表示假话的数目。</p><h4 id="数据范围">数据范围</h4><p><span class="math inline">\(1≤N≤50000\)</span> <span class="math inline">\(0≤K≤100000\)</span></p><h4 id="输入样例">输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs input">100 7<br>1 101 1 <br>2 1 2<br>2 2 3 <br>2 3 3 <br>1 1 3 <br>2 3 1 <br>1 5 5<br></code></pre></td></tr></table></figure><h4 id="输出样例">输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">3<br></code></pre></td></tr></table></figure><h2 id="二分析">二、分析</h2><p>由题意知，<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>、<span class="math inline">\(C\)</span> 三类动物之间的关系为：</p><p><img src="https://s1.ax1x.com/2023/07/25/pCXarvj.png" style="zoom:67%;"></p><p>假设节点<code>x</code>与根节点之间的距离为<code>d[x]</code>。若两个节点与根节点之间的距离模三相同，即<code>(d[x] - d[y]) % 3 == 0</code>，则表示两个节点是同类；若两个节点与根节点之间的距离模三差为 <span class="math inline">\(1\)</span>，即<code>(d[x] - d[y] - 1) % 3 == 0</code>，则表示两个节点是吃与被吃的关系，<code>x</code>节点吃<code>y</code>节点。</p><blockquote><p><strong>为什么不能直接比较两个节点与根节点之间的差值？</strong>、</p><p>因为距离是正值，差值可能为负值。当使用两个节点与根节点之间的差值计算时：</p><ul><li>比较两个节点是否为同类，差值比较<code>d[x] % 3 == d[y] % 3</code>。此时，如果<code>d[x] % 3</code>为负值、<code>d[y] % 3</code>为正值（假设前者为 <span class="math inline">\(d[x] = -4\)</span>、后者为 <span class="math inline">\(d[y] = 2\)</span>），易知<code>d[x]</code>和<code>d[y]</code>是同类，但是通过差值判断的结论却恰恰相反。通过作差或转为符号相同的即可判断，即<code>d[x] - d[y] % 3 == 0</code>或<code>(d[x] % 3 + 3) % 3 == (d[y] % 3 + 3) % 3</code>。</li><li>比较两个节点是否存在吃与被吃的关系同理。</li></ul></blockquote><p>在并查集中，将所有动物（节点）都存储在一个集合中，通过其与根节点之间的距离表示动物的类别，通过不同类别的动物在集合中与根节点的距离不同可以表示动物之间的吃与被吃的关系。</p><p>如上图中，不同类别的动物在集合中与根节点的距离模三的结果不同，结果 <span class="math inline">\(0,1,2\)</span> 分别表示 <span class="math inline">\(A,B,C\)</span> 三种不同的动物。其中，<span class="math inline">\(0\)</span> 吃 <span class="math inline">\(2\)</span>、<span class="math inline">\(1\)</span> 吃 <span class="math inline">\(0\)</span>、<span class="math inline">\(2\)</span> 吃 <span class="math inline">\(1\)</span>。</p><h2 id="三题解">三、题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>;<br><span class="hljs-comment">// p[]表示当前结点的父节点, d[]表示与根节点之间的距离</span><br><span class="hljs-comment">// 与根节点距离模三为0 -&gt; 被与根节点距离模三为1的吃</span><br><span class="hljs-comment">// 与根节点距离模三为1 -&gt; 被与根节点距离模三为2的吃</span><br><span class="hljs-comment">// 与根节点距离模三为2 -&gt; 被与根节点距离模三为0的吃</span><br><span class="hljs-type">int</span> n, k, p[N], d[N], ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)<br>    &#123;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">find</span>(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 检查是否为假话</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> op, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt; n || y &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// 动物编号越界假话</span><br>    <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x), py = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)    <span class="hljs-comment">// x 和 y 是同一类</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (px == py &amp;&amp; (d[x] - d[y]) % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// x和y在一个集合中  不满足x和y是同一类的条件</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (px != py) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <span class="hljs-comment">// x 和 y 不在同一个集合中</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>)   <span class="hljs-comment">// x 吃 y</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (px == py &amp;&amp; (d[x] - d[y] - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// x 和 y 在一个集合中  x 不满足吃 y 的距离条件</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (px != py) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <span class="hljs-comment">// x 和 y 不在同一个集合中</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 重复出现相同条件</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br>    <span class="hljs-keyword">while</span> (k -- )<br>    &#123;<br>        <span class="hljs-type">int</span> op, x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);<br>        <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x), py = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(op, x, y)) &#123; ans++; <span class="hljs-keyword">continue</span>; &#125;  <span class="hljs-comment">// 假话</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (px != py)  <span class="hljs-comment">// x 和 y 不在同一个集合中, 更新 x 和 y 所在的集合</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br>            &#123;<br>                p[px] = py;     <span class="hljs-comment">// 设置x所在集合的根节点</span><br>                d[px] = d[y] - d[x];    <span class="hljs-comment">// 设置x到新的根节点的距离, 使x和y为同一类</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                p[px] = py;     <span class="hljs-comment">// 设置x所在集合的根节点</span><br>                d[px] = d[y] - d[x] + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 设置x到新的根节点的距离, 使x能够吃y</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/07/24/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/07/24/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集">并查集</h1><blockquote><p>朴素并查集、维护每个集合里面数量的并查集、计算偏移量的并查集</p></blockquote><p><strong>并查集的两个用途：</strong></p><ol type="1"><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol><blockquote><p>虽然暴力做法也可以实现，但是使用并查集可以在近乎 <span class="math inline">\(O(1)\)</span> 的时间复杂度内实现。</p></blockquote><h2 id="朴素并查集">2.5.1 朴素并查集</h2><h3 id="基本思想">基本思想：</h3><p>对于每个集合，用一个树来表示。树根的编号就是整个集合的编号，每个节点存储他的父节点编号，即<code>p[x]</code>表示<code>x</code>的父节点。</p><p><img src="https://s1.ax1x.com/2023/07/24/pCLaI8H.png" style="zoom:67%;"></p><p>其中，每个树的根节点的编号表示当前集合的编号，可以通过<code>p[x] == x</code>判断，非根节点的编号的<code>p[]</code>数组为其父节点的编号，如<code>p[x] = y</code>。</p><h3 id="如何查找节点属于哪个集合">如何查找节点属于哪个集合？</h3><p>例如，求节点<code>x</code>属于哪个集合？</p><p>可以通过数组<code>p[]</code>，判断其是否满足树根的条件，即是否满足<code>p[x] == x</code>。当不满足树根条件时，继续判断<code>p[p[x]] == p[x]</code>，直到满足树根条件为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(p[x] != x) x = p[x]<br></code></pre></td></tr></table></figure><h3 id="如何合并两个集合">如何合并两个集合？</h3><p>假设<code>px</code>是<code>x</code>的集合编号，<code>py</code>是<code>y</code>的集合编号，则合并操作的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">p[x] = y;<br></code></pre></td></tr></table></figure><h3 id="并查集的优化">并查集的优化</h3><p>在查找当前节点属于哪个集合的时候，每次都需要从当前节点遍历到根节点，且遍历的节点个数和树的高度呈正比。因此，对于一些情况（如，反复查找某个叶子节点），可能时间复杂度与暴力做法相比差不多。</p><p>此时，可以使用<strong>路径压缩</strong>优化。对于遍历过程中的每个节点，在遍历结束后，如果找到了根节点的话，所有经过的节点的<code>p[]</code>都指向根节点。</p><blockquote><p>并查集的优化方式主要有两种：<strong>路径压缩</strong> 和 <strong>按秩合并</strong></p><p>其中，路径压缩的优化效果显著，可以使并查集的时间复杂度近似于 <span class="math inline">\(O(1)\)</span>；而按秩合并对并查集的优化效果不如路径压缩显著。</p></blockquote><p><img src="https://s1.ax1x.com/2023/07/24/pCLao2d.png" style="zoom:80%;"></p><h3 id="代码模板">代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><h2 id="维护size的并查集">2.5.2 维护size的并查集</h2><p>所维护的 <code>size</code> 表示当前集合中点的个数，根节点编号为<code>x</code>，则当前集合中的点的个数为<code>size[x]</code>。当合并两个集合的时候，需要将集合的<code>size</code>想加，赋值给合并后的集合的<code>size</code>。</p><p><img src="https://s1.ax1x.com/2023/07/25/pCXaqVx.png" style="zoom:80%;"></p><h3 id="代码模板-1">代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><span class="hljs-type">int</span> p[N], size[N];<br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    size[i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>size[<span class="hljs-built_in">find</span>(b)] += size[<span class="hljs-built_in">find</span>(a)];<br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><h2 id="维护到祖宗节点距离的并查集">2.5.3 维护到祖宗节点距离的并查集</h2><h3 id="代码模板-2">代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><span class="hljs-type">int</span> p[N], d[N];<br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)<br>    &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = u;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    p[i] = i;<br>    d[i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>朴素并查集</tag>
      
      <tag>维护size的并查集</tag>
      
      <tag>维护到祖宗节点距离的并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie树</title>
    <link href="/2023/07/22/Trie%E6%A0%91/"/>
    <url>/2023/07/22/Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="trie-树">Trie 树</h1><blockquote><p>Trie树，也叫字典树，是用来高效地<strong>存储</strong>和<strong>查找</strong>字符串集合的数据结构。</p></blockquote><h2 id="trie树的存储">1. Trie树的存储</h2><p>假设要在Trie树中存储字符串<code>abcdef</code>、<code>abdef</code>、<code>aced</code>、<code>bcdf</code>、<code>bcff</code>、<code>cdaa</code>、<code>bcdc</code>、<code>abc</code>（要么全是小写字母，要么全是大写字母，要么全是数字，要么全是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span>，而且字母的个数不会很多），在每个单词结尾的节点会做一个标记，表示存在一个以该节点所对应的字母结尾的单词，Trie树如下图所示：</p><p><img src="https://s1.ax1x.com/2023/07/24/pCLagDx.png" style="zoom: 50%;"></p><h2 id="trie树的查找">2. Trie树的查找</h2><p>Trie树的查找分为三种情况：</p><ol type="1"><li>查找成功。例如，查找字符串<code>aced</code>时，通过遍历Trie树到达节点<code>d</code>后，判断其存在标记，故查找成功。</li><li>由于最后一个节点不存在标记点而查找失败。例如，查找字符串<code>abcd</code>时，通过遍历Trie树找到了节点<code>d</code>，但是在节点<code>d</code>上不存在标记，因此查找失败。</li><li>由于不存在节点而查找失败。例如，查找字符串<code>abcf</code>，在遍历Trie树的时候，遍历到节点<code>c</code>，其下一个节点为<code>f</code>，但是在Trie树中当前节点<code>c</code>不存在一个<code>f</code>的后继节点，因此查找失败。</li></ol><p><img src="https://s1.ax1x.com/2023/07/24/pCLa2b6.png" style="zoom:80%;"></p><h2 id="代码模板">3. 代码模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-comment">// 0号点既是根节点，又是空节点</span><br><span class="hljs-comment">// son[][]存储树中每个节点的子节点</span><br><span class="hljs-comment">// cnt[]存储以每个节点结尾的单词数量</span><br><span class="hljs-comment">// idx用于记录Trie中当前节点的数量</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>    cnt[p] ++ ;<br>&#125;<br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing143. 最大异或对</title>
    <link href="/2023/07/22/%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9/"/>
    <url>/2023/07/22/%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="acwing143.-最大异或对">AcWing143. 最大异或对</h1><blockquote><p>原题链接：<a href="https://www.acwing.com/problem/content/145/">143. 最大异或对 - AcWing题库</a></p></blockquote><h2 id="一题目">一、题目</h2><p>在给定的 <span class="math inline">\(N\)</span> 个整数 <span class="math inline">\(A_1，A_2……A_N\)</span> 中选出两个进行 <span class="math inline">\(xor\)</span>（异或）运算，得到的结果最大是多少？</p><h4 id="输入格式">输入格式</h4><p>第一行输入一个整数 <span class="math inline">\(N\)</span>。</p><p>第二行输入 <span class="math inline">\(N\)</span> 个整数 <span class="math inline">\(A_1～A_N\)</span>。</p><h4 id="输出格式">输出格式</h4><p>输出一个整数表示答案。</p><h4 id="数据范围">数据范围</h4><p><span class="math inline">\(1≤N≤10^5\)</span> <span class="math inline">\(0≤A_i&lt;2^{31}\)</span></p><h4 id="输入样例">输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs input">3<br>1 2 3<br></code></pre></td></tr></table></figure><h4 id="输出样例">输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">3<br></code></pre></td></tr></table></figure><h2 id="二分析">二、分析</h2><p><strong>异或运算（同 <span class="math inline">\(0\)</span> 异 <span class="math inline">\(1\)</span>）：</strong>异或运算是一种二进制位运算，也称异或操作。如果两个对应的二进制位相同，则异或的结果为 <span class="math inline">\(0\)</span>；如果两个对应的二进制位不同，则异或结果为 <span class="math inline">\(1\)</span>。</p><p><img src="https://s1.ax1x.com/2023/07/23/pCq6yp8.png" style="zoom: 50%;"></p><p><strong>性质：</strong>对于一个二进制数，如果要找到与其异或最大的数，则使高位与要找的数的对应位异或为 <span class="math inline">\(1\)</span>。</p><p><img src="https://s1.ax1x.com/2023/07/23/pCq661S.png" style="zoom:50%;"></p><hr><p><strong>暴力做法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-comment">// 枚举第一个数</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) <span class="hljs-comment">// 枚举第二个数</span><br>        ans = <span class="hljs-built_in">max</span>(ans, a[i] ^ a[j]);<br>&#125;<br></code></pre></td></tr></table></figure><p>第 <span class="math inline">\(2\)</span> 层<code>for</code>循环的含义：从<code>a[i+1]</code>到<code>a[n-1]</code>找到一个和<code>a[i]</code>异或最大的一个结果，内层循环的时间复杂度为 <span class="math inline">\(O(n)\)</span>，总体时间复杂度为 <span class="math inline">\(O(n^2)\)</span>。可以通过Trie树对内层<code>for</code>循环优化。</p><p><strong>Trie树优化：</strong></p><p>由题意知，每个整数都可以用 <span class="math inline">\(31\)</span> 位的二进制串来表示，再结合上面提到的异或的性质，则可以把每个整数表示成Trie树中的一个序列（其中，每个序列的存储是从高位开始的，即离根节点越近的结点在二进制数中的位数越高）。</p><p>当我们求解与<code>a[i]</code>异或的最大值时，需要遍历我们构造的Trie树，每次尽可能的往和当前位不同的位（图中紫色路径）上走。当走到叶节点的时候，我们就找到与当前<code>a[i]</code>异或最大的结果了。</p><p>此时，内层查找代码的时间复杂度为 <span class="math inline">\(O(31)\)</span>，则总体时间复杂度为 <span class="math inline">\(O(n)\)</span>。</p><h2 id="三题解">三、题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">3100010</span>;<br><span class="hljs-type">int</span> n, a[N], son[M][<span class="hljs-number">2</span>], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-type">int</span> u = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-type">int</span> u = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (son[p][!u])<br>        &#123;<br>            res += <span class="hljs-number">1</span> &lt;&lt; i;<br>            p = son[p][!u];<br>        &#125;<br>        <span class="hljs-keyword">else</span> p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>        <span class="hljs-built_in">insert</span>(a[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> max_res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        max_res = <span class="hljs-built_in">max</span>(max_res, <span class="hljs-built_in">search</span>(a[i]));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, max_res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Trie树</tag>
      
      <tag>位运算</tag>
      
      <tag>异或</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用conda命令</title>
    <link href="/2023/07/17/%E5%B8%B8%E7%94%A8conda%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/07/17/%E5%B8%B8%E7%94%A8conda%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="常用conda命令">常用Conda命令</h1><p><strong>查看已经创建的虚拟环境：</strong><code>conda env list</code></p><p><strong>创建conda虚拟环境：</strong><code>conda create -n your_env_name python=x.x</code></p><p><strong>激活conda虚拟环境：</strong><code>conda activate your_env_name</code></p><p><strong>删除conda虚拟环境：</strong><code>conda remove -n your_env_name --all</code></p><hr><p><strong>查看当前conda环境中安装了哪些包：</strong><code>conda list</code></p><p><strong>在虚拟环境中安装包：</strong><code>conda install -n your_env_name [package]</code></p><p><strong>检查更新当前conda：</strong><code>conda update conda</code></p>]]></content>
    
    
    <categories>
      
      <category>Conda</category>
      
    </categories>
    
    
    <tags>
      
      <tag>conda命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing3717. 整数序列</title>
    <link href="/2023/07/16/%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <url>/2023/07/16/%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="acwing3717.-整数序列">AcWing3717. 整数序列</h1><blockquote><p>原题链接：<a href="https://www.acwing.com/problem/content/description/3720/">3717. 整数序列 - AcWing题库</a></p></blockquote><h2 id="一题目">一、题目</h2><p>很多整数可以由一段连续的<strong>正整数</strong>序列（至少两个数）相加而成，比如<span class="math inline">\(25=3+4+5+6+7=12+13\)</span>。</p><p>输入一个整数 <span class="math inline">\(N\)</span>，输出 <span class="math inline">\(N\)</span> 的全部正整数序列，如果没有则输出 <code>NONE</code>。</p><p><strong>输入格式</strong></p><p>一个整数 <span class="math inline">\(N\)</span>。</p><p><strong>输出格式</strong></p><p>每行输出一个满足条件的整数序列。</p><p>序列内部元素从小到大排序。</p><p>优先输出首项更小的序列。</p><p><strong>数据范围</strong></p><p><span class="math inline">\(2≤N≤10^7\)</span></p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs input">25<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs output">3 4 5 6 7<br>12 13<br></code></pre></td></tr></table></figure><h2 id="二分析">二、分析</h2><h4 id="二分">二分</h4><p>枚举首项，通过二分找到尾项，使满足 <span class="math inline">\(n=\frac{(a+b)n}{2}\)</span>。其中，<span class="math inline">\(a\)</span> 为首项、<span class="math inline">\(b\)</span> 为尾项。</p><h4 id="数学知识推公式-分解质因数">数学知识（推公式 + 分解质因数）</h4><blockquote><p>等差数列前 <span class="math inline">\(n\)</span> 项和公式：$ S_n=na_1+{d} $</p></blockquote><p>设答案序列首项为 <span class="math inline">\(a\)</span>，共 <span class="math inline">\(k\)</span> 项，且有题目知公差为 <span class="math inline">\(1\)</span>，则所求的序列为 <span class="math inline">\(a\)</span>、<span class="math inline">\(a+1\)</span>、<span class="math inline">\(a+2\)</span>、<span class="math inline">\(…\)</span>、<span class="math inline">\(a+k-1\)</span>。</p><p>由等差数列前 <span class="math inline">\(n\)</span> 项和公式得：<span class="math inline">\(n=ka+{\frac{k\left( k-1 \right)}{2}}\)</span></p><p>从而得到：<span class="math inline">\(2n=k(2a+k-1)\)</span></p><p>设 <span class="math inline">\(x=k\)</span>、<span class="math inline">\(y=2a+k-1\)</span>，则 <span class="math inline">\(xy=2n\)</span> 。</p><p><strong>推条件：</strong>由题意知，首项 <span class="math inline">\(a&gt;0\)</span> ，则 <span class="math inline">\(2a=y-x+1&gt;0\)</span>，<span class="math inline">\(y&gt;x-1\)</span>，即 <span class="math inline">\(x\leqslant y\)</span>；由于首项 <span class="math inline">\(a\)</span> 为整数，且首项 <span class="math inline">\(a\)</span> 满足 <span class="math inline">\(2a=y-x+1&gt;0\)</span>，即 <span class="math inline">\(a=\frac{y-x+1}{2}\)</span>，即 <span class="math inline">\(y-x+1\)</span> 为偶数。</p><p><strong>推范围：</strong>由于 <span class="math inline">\(x\leqslant y\)</span>，且 <span class="math inline">\(xy=2n\)</span>，得 <span class="math inline">\(x\leqslant {\frac{2n}{x}}\)</span>，即 <span class="math inline">\(x\leqslant \sqrt{2n}\)</span>。</p><p><strong>输出要求：</strong>由于要先输出尽可能小的数，已知 <span class="math inline">\(a\)</span> 为首项，因此只要让 <span class="math inline">\(a\)</span> 由小往大遍历即可。由上面的等式可以得到 <span class="math inline">\(2a = \frac{2n}{k}-(k+1)\)</span>，可见 <span class="math inline">\(a\)</span> 会随 <span class="math inline">\(k\)</span> 的增加而减少 ，且由于 <span class="math inline">\(x=k\)</span>，因此只要让 <span class="math inline">\(x\)</span> 由大往小遍历即可。</p><h2 id="三题解">三、题解</h2><p>不知道为什么二分的时间会更长</p><p><img src="https://s1.ax1x.com/2023/07/17/pCI4oi6.png" alt="image-20230716234258894" style="zoom:80%;"></p><blockquote><p><strong>ChatGPT是这样说的：</strong></p><p>首先，我们来看一下它们的时间复杂度：</p><ul><li>二分方法的代码：在平均情况下，二分查找算法的时间复杂度为O(logn)。由于在每次迭代中，我们将搜索范围减半，因此该代码的时间复杂度可以近似为O(logn)。</li><li>暴力枚举的代码：在该代码中，我们使用了一个循环来逐步增加序列的长度，直到找到满足条件的序列。因此，该代码的时间复杂度为O(n)。</li></ul><p>现在我们来解释为什么"二分方法的代码"的运行时间较长：</p><ol type="1"><li>二分方法的代码中使用了二分查找来寻找满足条件的序列的起始和结束位置。这需要多次进行二分查找操作，每次查找都需要将搜索范围减半。虽然二分查找的时间复杂度较低，但它在一次迭代中进行了多次查找。</li><li>每次二分查找中，我们还需要进行一些复杂的乘法和除法运算来计算中间位置的值。这些运算需要一定的时间。</li><li>此外，二分方法的代码还包含了一些其他的操作，如条件判断和循环控制。这些操作也会增加代码的运行时间。</li></ol><p>因此，相对于暴力枚举的代码，二分方法的代码需要进行更多的操作和计算，导致其运行时间更长。在特定情况下，例如当输入的n较大时，二分方法的代码的差距会更加明显。</p></blockquote><h4 id="方法一暴力枚举-on2">方法一：暴力枚举 <span class="math inline">\(O(n^2)\)</span></h4><p>没想到暴力也能过٩(๑&gt;◡&lt;๑)۶</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, j = i;<br>        <span class="hljs-keyword">while</span> (sum + j &lt; n) sum += j, j++;<br>        <span class="hljs-keyword">if</span> (sum + j == n) <br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt;= j; k++) <br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k); <br>            flag = <span class="hljs-literal">true</span>; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NONE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二二分">方法二：二分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; a &lt;= n / <span class="hljs-number">2</span>; a++)<br>    &#123;<br>        <span class="hljs-type">int</span> l = a + <span class="hljs-number">1</span>, r = n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) <br>        &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-comment">// 在后续计算中使用乘法会导致超出int的范围, 因此选择使用long long类型</span><br>            <span class="hljs-keyword">if</span> ((a + mid) * (mid - a + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &gt;= n) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((a + l) * (l - a + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> == n) <br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = a; k &lt;= l; k++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, k); <br>            flag = <span class="hljs-literal">true</span>; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NONE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法三数学知识">方法三：数学知识</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span> * n); x &gt;= <span class="hljs-number">2</span>; x--)<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * n % x == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> y = <span class="hljs-number">2</span> * n / x;<br>            <span class="hljs-type">int</span> k = x;<br>            <span class="hljs-type">int</span> t = y - x + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = t / <span class="hljs-number">2</span>; i &lt; k; i++, j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, j);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NONE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>数学知识</tag>
      
      <tag>试除法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing3302. 表达式求值</title>
    <link href="/2023/07/12/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2023/07/12/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="acwing3302.-表达式求值">AcWing3302. 表达式求值</h1><blockquote><p><strong>原题链接：</strong><a href="https://www.acwing.com/problem/content/3305/">3302. 表达式求值 - AcWing题库</a></p></blockquote><h2 id="一题目">一、题目</h2><p>给定一个表达式，其中运算符仅包含 <code>+,-,*,/</code>（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p><p><strong>注意：</strong></p><ul><li>数据保证给定的表达式合法。</li><li>题目保证符号 <code>-</code> 只作为减号出现，不会作为负号出现，例如，<code>-1+2</code>,<code>(2+2)*(-(1+1)+2)</code> 之类表达式均不会出现。</li><li>题目保证表达式中所有数字均为正整数。</li><li>题目保证表达式在中间计算过程以及结果中，均不超过 <span class="math inline">\(2^{31}−1\)</span>。</li><li>题目中的整除是指向 00 取整，也就是说对于大于 00 的结果向下取整，例如 <span class="math inline">\(5/3=1\)</span>，对于小于 <span class="math inline">\(0\)</span> 的结果向上取整，例如 <span class="math inline">\(5/(1−4)=−1\)</span>。</li><li>C++和Java中的整除默认是向零取整；Python中的整除<code>//</code>默认向下取整，因此Python的<code>eval()</code>函数中的整除也是向下取整，在本题中不能直接使用。</li></ul><p><strong>输入格式</strong></p><p>共一行，为给定表达式。</p><p><strong>输出格式</strong></p><p>共一行，为表达式的结果。</p><p><strong>数据范围</strong></p><p>表达式的长度不超过 <span class="math inline">\(10^5\)</span>。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs input">(2+2)*(1+1)<br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">8<br></code></pre></td></tr></table></figure><h2 id="二样例分析">二、样例分析</h2><p>题目中所给的表达式为<strong>中缀表达式</strong>，先将其转化为<strong>中缀表达式树</strong>（所有内部结点都是运算符、所有叶子结点都是数）：</p><p><img src="https://s1.ax1x.com/2023/07/16/pCInwKf.png" style="zoom:100%;"></p><p>中序遍历树得到的中缀表达式要加括号（保证运算符的优先级），即结果为 <span class="math inline">\((2+2)×(1+1)\)</span> 而非 <span class="math inline">\(2+2×1+1\)</span> ；后序遍历树得到的后缀表达式不需要加括号，即结果为 <span class="math inline">\(2\ 2+1\ 1+×\)</span> 。</p><p>可以通过<strong>递归</strong>的方式求解：</p><p><img src="https://s1.ax1x.com/2023/07/16/pCInBqS.png" style="zoom:100%;"></p><p><strong>中序遍历+栈：</strong></p><p><img src="https://s1.ax1x.com/2023/07/16/pCInrVg.png" style="zoom:100%;"></p><h2 id="三题解">三、题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span><span class="hljs-comment">// 哈希表</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>stack&lt;<span class="hljs-type">int</span>&gt; num;<span class="hljs-comment">// 存数字</span><br>stack&lt;<span class="hljs-type">char</span>&gt; op;<span class="hljs-comment">// 存运算符</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> b = num.<span class="hljs-built_in">top</span>(); num.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 取出第二个数字</span><br>    <span class="hljs-keyword">auto</span> a = num.<span class="hljs-built_in">top</span>(); num.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 取出第一个数字</span><br>    <span class="hljs-keyword">auto</span> c = op.<span class="hljs-built_in">top</span>(); op.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 取出运算符</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-comment">// 计算</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span>) x = a + b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>) x = a - b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;*&#x27;</span>) x = a * b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) x = a / b;<br>    num.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">// 将计算结果存入栈中</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; pr&#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>&#125;&#125;;<span class="hljs-comment">// 定义各个运算符的优先级, 数越大优先级越大</span><br>    string str;<br>    cin &gt;&gt; str;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> c = str[i];<span class="hljs-comment">// 存取当前字符</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c))<span class="hljs-comment">// 如果当前字符是数字, 把当前的数字取出来</span><br>        &#123;<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(str[j]))<br>                x = x * <span class="hljs-number">10</span> + str[j++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            i = j - <span class="hljs-number">1</span>;<span class="hljs-comment">// 变化指针i的位置</span><br>            num.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">// 把数字放到栈里</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) op.<span class="hljs-built_in">push</span>(c);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-built_in">eval</span>();<span class="hljs-comment">// 把栈里面所有运算符从右往左操作一遍, 直到遇到 (</span><br>            op.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">// 弹出左括号</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 一般的运算符</span><br>        &#123;<br>            <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>() &amp;&amp; op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="hljs-built_in">top</span>()] &gt;= pr[c]) <span class="hljs-built_in">eval</span>();<span class="hljs-comment">// 运算符栈不为空, 且栈顶元素优先级高于当前元素, 循环操作高优先级运算符</span><br>            op.<span class="hljs-built_in">push</span>(c);<span class="hljs-comment">// 将当前运算符存入栈</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">eval</span>();<span class="hljs-comment">// 从右往左操作一遍运算符</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, num.<span class="hljs-built_in">top</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>表达式求值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列</title>
    <link href="/2023/07/09/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2023/07/09/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈与队列单调队列单调栈">栈与队列：单调队列、单调栈</h1><blockquote><p>使用<strong>数组</strong>模拟</p></blockquote><p><img src="https://s1.ax1x.com/2023/07/16/pC5OlxP.png" style="zoom:80%;"></p><h2 id="栈">1. 栈</h2><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// tt表示栈顶下标</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[++tt] = x;<br><br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt--;<br><br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><br><span class="hljs-comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列">2. 队列</h2><h3 id="普通队列">1. 普通队列</h3><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[++tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh++;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环队列">2. 循环队列</h3><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// hh 表示队头，tt表示队尾的后一个位置</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[tt++] = x;<br><span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh++;<br><span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh != tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调栈">3. 单调栈</h2><blockquote><p><strong>常见题型：</strong>给定一个序列，找到这个序列中每一个数左边离它最近的数的位置。</p></blockquote><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; <span class="hljs-built_in">check</span>(stk[tt], i)) tt -- ;<br>    stk[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列">4. 单调队列</h2><blockquote><p><strong>最经典的应用：</strong>求滑动窗口中的最大值或最小值</p></blockquote><p><strong>模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check_out</span>(q[hh])) hh ++ ;  <span class="hljs-comment">// 判断队头是否滑出窗口</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check</span>(q[tt], i)) tt -- ;<br>    q[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
      <tag>单调栈</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表与邻接表</title>
    <link href="/2023/07/08/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    <url>/2023/07/08/%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表与邻接表树与图的存储">链表与邻接表：树与图的存储</h1><ul><li><p>使用<strong>数组</strong>模拟（静态链表）</p></li><li><p>使用<strong>指针</strong>+<strong>结构体</strong>模拟（动态链表、在笔试题中一般不会用）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    Node *next;<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(); <span class="hljs-comment">// 非常慢</span><br></code></pre></td></tr></table></figure><h2 id="使用数组模拟单链表">1. 使用数组模拟单链表</h2><p>在算法题中，使用最多的单链表是邻接表（n个链表）</p><h3 id="单链表与邻接表">1.1 单链表与邻接表</h3><p><strong>邻接表的用途：</strong>存储数与图</p><p>在单链表中，用<code>e[ ]</code>表示该结点的值，用<code>ne[ ]</code>表示该结点的下一结点的编号。</p><p><img src="https://s1.ax1x.com/2023/07/16/pC5OQ2t.png" style="zoom:80%;"></p><h3 id="单链表的优缺点单链表是只往后看的">1.2 单链表的优缺点（单链表是只往后看的）</h3><p><strong>优点：</strong>单链表可以用 <span class="math inline">\(O(1)\)</span> 的时间找到下一个结点的位置</p><p><strong>缺点：</strong>单链表不能用 <span class="math inline">\(O(1)\)</span> 的时间找到上一个结点的位置（只能从头开始遍历）</p><h3 id="模板">1.3 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx++;<br>&#125;<br><br><span class="hljs-comment">// 在链表第k个结点后面插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = ne[k], ne[k] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = ne[head];<br>&#125;<br><br><span class="hljs-comment">// 将下标是k的点后面的点删掉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k] = ne[ne[k]];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用数组模拟双链表">2. 使用数组模拟双链表</h2><p><strong>双链表的用途：</strong>优化某些问题</p><ul><li>双链表与单链表的区别在于：单链表只有一个方向，双链表是双向的</li></ul><h3 id="模板-1"><strong>模板</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//0是左端点，1是右端点</span><br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 在节点a的右边插入一个数x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    l[idx] = a, r[idx] = r[a];<br>    l[r[a]] = idx, r[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 删除节点a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    l[r[a]] = l[a];<br>    r[l[a]] = r[a];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单链表</tag>
      
      <tag>双链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间合并</title>
    <link href="/2023/07/04/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <url>/2023/07/04/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="区间合并">区间合并</h1><p><strong>应用场景：</strong>将 <span class="math inline">\(n\)</span> 个区间中，所有有交集的区间合并（假设两个区间只有端点相交的，那么他们也是可以合并的）。</p><p><img src="https://s1.ax1x.com/2023/07/15/pC5Qrvt.png" style="zoom:80%;"></p><p><strong>算法步骤：</strong></p><ol type="1"><li><p>按区间的左端点排序</p></li><li><p>扫描整个区间，把所有有交集的区间合并</p></li></ol><h2 id="模板">模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//区间按照做端点排序</span><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<span class="hljs-comment">// 定义+无穷和-无穷</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区间合并</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散化</title>
    <link href="/2023/07/04/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <url>/2023/07/04/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="离散化">离散化</h1><blockquote><p>特指整数的离散化、保序的离散化</p></blockquote><p><strong>序列特点：</strong>值域较大（<span class="math inline">\(0\)</span> ~ <span class="math inline">\(10^9\)</span>）、个数较少（可能只有<span class="math inline">\(10^5\)</span>个数）</p><p>有些题目可能要以这些序列的值为下标来做，因此需要把序列映射到从 <span class="math inline">\(0\)</span> 开始的连续的自然数。</p><p><img src="https://s1.ax1x.com/2023/07/15/pC5QM4J.png" style="zoom:80%;"></p><p><strong>离散化中常见的两个问题：</strong></p><ol type="1"><li><code>a[]</code>中可能有重复元素 -&gt; 去重</li><li>如何计算<code>x</code>离散化后的值 -&gt; 二分查找</li></ol><h2 id="模板">模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2023/07/04/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2023/07/04/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算">位运算</h1><p>常用的两种位运算的操作：求 <span class="math inline">\(n\)</span> 的第 <span class="math inline">\(k\)</span> 位数字和 <span class="math inline">\(n\)</span> 的最后一位</p><h2 id="n的二进制表示中第k位">1. n的二进制表示中第k位</h2><p><strong>思路：</strong></p><ol type="1"><li>先把第 <span class="math inline">\(k\)</span> 位移到最后一位，即<code>n &gt;&gt; k</code></li><li>看一下最低位是几，<code>x &amp; 1</code></li></ol><p>结合①和②，得到公式：<code>n &gt;&gt; k &amp; 1</code></p><blockquote><p>位移运算不会改变原数据的值，即<code>n &gt;&gt; k</code>前后<code>n</code>的值不变</p></blockquote><h2 id="n的二进制表示中最后一位">2. n的二进制表示中最后一位</h2><p><code>lowbit()</code>是树状数组的基本操作，<code>lowbit(x)</code>的作用是返回<code>x</code>的最后一位<code>1</code>。例如：如果二进制数<code>x = 1010</code>，则<code>lowbit(x)</code>返回的是<code>10</code>，即十进制数<code>2</code>；如果二进制数<code>x = 101000</code>，则<code>lowbit(x)</code>返回的是<code>1000</code>，即十进制数<code>8</code>。</p><p><strong>实现：</strong><code>lowbit(x) = x &amp; -x</code>。其中，<code>-x</code>是<code>x</code>的补码，即<code>x</code>取反加一</p><p><strong>应用：</strong>统计<code>x</code>的二进制表示中<code>1</code>的个数。每次把最后一位<code>1</code>减掉，当<code>x</code>的值为<code>0</code>时停止，统计循环次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求n的第k位数字: </span><br>n &gt;&gt; k &amp; <span class="hljs-number">1</span><br><span class="hljs-comment">// 返回n的最后一位1：</span><br><span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二进制的第k位</tag>
      
      <tag>lowbit( )</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针算法</title>
    <link href="/2023/07/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <url>/2023/07/03/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针算法">双指针算法</h1><ul><li><p><strong>第一类：</strong>指向的是<strong>两个序列</strong>，例如：归并排序中的双指针</p></li><li><p><strong>第二类：</strong>指向的是<strong>一个序列</strong>（常见），例如：快速排序的双指针</p></li></ul><h2 id="核心思想">1. 核心思想</h2><p>将下面的朴素算法的时间复杂度优化到 <span class="math inline">\(O(n)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        <span class="hljs-comment">// 操作</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么双指针算法的时间复杂度是 <span class="math inline">\(O(n)\)</span> ?</strong></p><p>双指针算法的时间复杂度为 <span class="math inline">\(O(n)\)</span> 的原因是，它通常在一个循环中使用两个指针进行迭代，而这两个指针相对于输入规模 <span class="math inline">\(n\)</span> 的数量级是线性的。</p><p>在双指针算法中，指针通常从输入序列的两端开始，然后向中间移动，根据特定的条件调整指针的位置。算法的终止条件可能是两个指针相遇或到达特定位置。</p><p>由于每次迭代中，指针的移动都是以固定的步长进行的，而且指针从两个方向同时移动，因此整个算法的执行时间与输入规模 <span class="math inline">\(n\)</span> 成线性关系。换句话说，算法的运行时间随着输入规模的增加而线性增长。</p><p>需要注意的是，虽然双指针算法的时间复杂度通常是 <span class="math inline">\(O(n)\)</span>，但也可以有特殊情况下的变体，其时间复杂度可能是 <span class="math inline">\(O(n^2)\)</span> 或其他不同的复杂度。这取决于算法的具体实现和问题的特定要求。但是，一般而言，双指针算法的时间复杂度是线性的，即 <span class="math inline">\(O(n)\)</span>。</p></blockquote><h2 id="例子">2. 例子</h2><p><strong>题目要求：</strong></p><p>输入一个字符串，其中包含多个单词，每个单词用空格隔开，输出每个单词。（假定字符串开始时没有空格，且每个单词之间只有一个空格）</p><p><strong>分析：</strong></p><p><img src="https://s1.ax1x.com/2023/07/15/pC5M5nK.png" style="zoom:80%;"></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">1000</span>];<br>    <span class="hljs-built_in">gets</span>(str);<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; str[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++;<br>        <span class="hljs-comment">// 这道题的具体逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; k++) cout &lt;&lt; str[k];<br>        cout &lt;&lt; endl;<br>        i = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板">3. 模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j++ ;<br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br><span class="hljs-comment">// 常见问题分类：</span><br>    <span class="hljs-comment">// (1) 对于一个序列，用两个指针维护一段区间</span><br>    <span class="hljs-comment">// (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></code></pre></td></tr></table></figure><p><strong>总结（双指针算法的实现思路）</strong></p><ol type="1"><li>写出题目对应的暴力解法（时间复杂度为 <span class="math inline">\(O(n^2)\)</span>），寻找两个循环索引 <span class="math inline">\(i、j\)</span> 之间的单调关系</li><li>如果有单调关系的话，利用其单调关系，把状态数量由 <span class="math inline">\(n^2\)</span> 变成 <span class="math inline">\(n\)</span>，从而把时间复杂度由 <span class="math inline">\(O(n^2)\)</span> 变成 <span class="math inline">\(O(n)\)</span></li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2023/07/02/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2023/07/02/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和与差分">前缀和与差分</h1><p><strong>差分：</strong><span class="math inline">\(a_1\)</span>、<span class="math inline">\(a_2\)</span>、<span class="math inline">\(a_3\)</span>、……、<span class="math inline">\(a_n\)</span> （下标从 <span class="math inline">\(1\)</span> 开始）</p><p><strong>前缀和：</strong><span class="math inline">\(S_1\)</span>、<span class="math inline">\(S_2\)</span>、<span class="math inline">\(S_3\)</span>、……、<span class="math inline">\(S_n\)</span> 其中，<span class="math inline">\(S_i=a_1+a_2+a_3+...+a_i\)</span> （下标从 <span class="math inline">\(1\)</span> 开始，定义 <span class="math inline">\(S_0=0\)</span>）</p><h2 id="前缀和">1. 前缀和</h2><h4 id="涉及到的两个问题">1. 涉及到的两个问题</h4><ol type="1"><li><p>如何求 <span class="math inline">\(S_i\)</span> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一维前缀和的初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<span class="hljs-comment">// 前缀和的初始化</span><br><span class="hljs-comment">// 二维前缀和的初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        s[i][j] = a[i][j] + s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li><li><p>前缀和数组 <span class="math inline">\(S_i\)</span> 的作用：快速求出原数组中的一段数的和。</p><blockquote><p><strong>前缀和数组作用的例子：</strong>假设题目要求求出数组中<code>[l, r]</code>的数的和（区间和的计算）</p><ul><li>如果没有前缀和数组，则需循环一遍求解，此时时间复杂度为 <span class="math inline">\(O(n)\)</span></li><li>如果有前缀和数组，则可直接计算得出 <span class="math inline">\(S_r-S_{l-1}\)</span>，此时时间复杂度为 <span class="math inline">\(O(1)\)</span></li></ul></blockquote></li></ol><h4 id="为什么前缀和的下标从1开始">2. 为什么前缀和的下标从1开始</h4><p><strong>主要是处理边界问题：</strong>当需要求数组<code>[1, t]</code>的数的和的时候，可以直接通过 <span class="math inline">\(S_t-S_0\)</span>，不用考虑边界问题。同时，这也是把 <span class="math inline">\(S_0\)</span> 定义为 <span class="math inline">\(0\)</span> 的原因。虽然该问题可以直接以 <span class="math inline">\(S_t\)</span> 为答案，但是为了统一计算公式，选择这种计算方法。</p><h3 id="一维前缀和">1.1 一维前缀和</h3><p>作用：<strong>快速求出某一区间的和</strong></p><p><strong>原数组：</strong><span class="math inline">\(a_i\)</span></p><p><strong>前缀和数组：</strong><span class="math inline">\(S_i\)</span></p><p><strong>区间和计算公式：</strong><span class="math inline">\([l,\ r]=S_r-S_{l-1}\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="二维前缀和">1.2 二维前缀和</h3><p>与一维前缀和类似，二维前缀和是为了<strong>快速求出某一子矩阵的和</strong></p><p><strong>原数组：</strong><span class="math inline">\(a_{ij}\)</span></p><p><strong>前缀和数组：</strong><span class="math inline">\(S_{ij}\)</span></p><p><strong>子矩阵和计算公式：</strong> <span class="math display">\[\left[ \begin{matrix}    \left( x_1, y_1 \right)&amp;        \left( x_1, y_2 \right)\\    \left( x_2, y_1 \right)&amp;        \left( x_2, y_2 \right)\\\end{matrix} \right] =S_{x_2y_2}-S_{x_1-1 y_2}-S_{x_2\,\,y_1-1}+S_{x_1-1 y_1-1}\]</span> <img src="https://s1.ax1x.com/2023/07/15/pC5Mapn.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">S[i, j] =  <span class="hljs-comment">// 第i行j列格子左上部分所有元素的和</span><br><span class="hljs-comment">// 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/15/pC5Mw60.png" style="zoom:80%;"></p><h2 id="差分">2. 差分</h2><h4 id="差分的作用">1. 差分的作用</h4><p>对于数组 <span class="math inline">\(a_i\ (i=1,2,3,…,n)\)</span>，其前缀和为 <span class="math inline">\(s_i\ (i = 1,2,3,…,n)\)</span>。<span class="math inline">\(a_i\)</span> 为 <span class="math inline">\(s_i\)</span> 的差分，满足 <span class="math inline">\(a_i\ = s_i \ - \ s_{i-1}\)</span>，即： <span class="math display">\[a_1 = s_1\\a_2 = s_2-s_1\\a_3 = s_3-s_2\\a_4 = s_4-s_3\\……\\a_n = s_n-s_{n-1}\]</span> <strong>作用：</strong>对于前缀和数组 <span class="math inline">\(s_i\)</span> ，如果需要使其从第 <span class="math inline">\(l\)</span> 项开始到第 <span class="math inline">\(r\)</span> 项每项都增加一个常数 <span class="math inline">\(C\)</span> 。如果直接对前缀和数组 <span class="math inline">\(s_i\)</span> 操作的话，即对 <span class="math inline">\(s_i\ (i = l,l+1,…,r)\)</span> 每一项都增加一个常数 <span class="math inline">\(C\)</span>，程序的时间复杂度为 <span class="math inline">\(O(n)\)</span>；如果对差分数组 <span class="math inline">\(a_i\)</span> 操作的话，即使 <span class="math inline">\(a_l + C\)</span> 、<span class="math inline">\(a_{r+1} - C\)</span>，程序的时间复杂度为 <span class="math inline">\(O(1)\)</span>。</p><h3 id="一维差分">2.1 一维差分</h3><p><strong>作用：</strong>给一维数组的一段加上一个值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br></code></pre></td></tr></table></figure><blockquote><p><strong>过程：</strong></p><ol type="1"><li><p>定义前缀和数组，并输入初值（给 <span class="math inline">\(s_i\)</span> 赋初值）</p></li><li><p>根据前缀和数组的值，给差分数组赋初值（给 <span class="math inline">\(a_i\)</span> 赋值）</p><p>对于差分数组中的第 <span class="math inline">\(i\)</span> 个元素，采用插入的方式：对于区间<code>[i,i]</code>插入<code>s[i]</code>，即<code>a[i] + s[i]</code>、<code>a[i+1] - s[i]</code></p></li><li><p>根据差分数组，求出其前缀和即可</p></li></ol></blockquote><h3 id="二维差分">2.2 二维差分</h3><p><strong>作用：</strong>给二维数组数组的一个子矩阵加上一个值</p><p><img src="https://s1.ax1x.com/2023/07/15/pC5Ms7F.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></td></tr></table></figure><blockquote><p>过程同一维差分，只不过计算差分数组的方式不同</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度</title>
    <link href="/2023/07/01/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/2023/07/01/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度">高精度</h1><blockquote><p><code>A</code>和<code>B</code>的位数约为<span class="math inline">\(10^6\)</span>，即<code>len(A)</code>和<code>len(B)</code>的结果为<span class="math inline">\(10^6\)</span></p><p><code>a</code>的数值小于等于<span class="math inline">\(10^9\)</span>，即<code>a&lt;=10^9</code></p></blockquote><h2 id="大整数是如何表示的">1. 大整数是如何表示的</h2><p>用<code>int</code>肯定是不行的，一般把大整数存储在数组里，并且要存储的数的最低位要放在数组索引为<code>0</code>的位置，即倒序存储。</p><blockquote><p><strong>大整数存储要倒序的原因：</strong></p><p>在对大整数做运算时，很可能出现进位的情况。当正序存储且需要进位时，就需要把数组中的所有元素后移一位，腾出最高位的空间。但是这会大大提高程序运行的时间复杂度，因此选择使用倒序存储。</p></blockquote><p>大整数的运算是一个模拟人工加法/减法/乘法/除法的过程。</p><blockquote><p>通常以字符串的形式读入大整数，然后通过<code>for</code>循环遍历字符串中的每个元素，存储到<code>vector&lt;int&gt;</code>中。注意，在存储的时候，要将字符串中的字符元素转化为整型元素，即<code>a[i] - '\0'</code>.</p></blockquote><h2 id="两个比较大的整数相加ab">2. 两个比较大的整数相加<code>A+B</code></h2><h3 id="实现原理">2.1 实现原理</h3><p><img src="https://s1.ax1x.com/2023/07/14/pC4xFN4.png" style="zoom:100%;"></p><p><strong>串行进位加法器</strong>：从最低位开始计算，每一位的运算都是<span class="math inline">\(A_i+B_i+t\)</span>，其中<span class="math inline">\(A_i\)</span>是被加数的第<span class="math inline">\(i\)</span>位、<span class="math inline">\(B_i\)</span>是加数的第<span class="math inline">\(i\)</span>位、<span class="math inline">\(t\)</span>是上一位的进位。最初状态时，<span class="math inline">\(t\)</span>被赋初值<span class="math inline">\(0\)</span>，相当于向最低位的进位为<span class="math inline">\(0\)</span>。</p><h3 id="代码模板">2.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span><span class="hljs-comment">// 接收结果时, 可以使用auto类型</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    vector&lt;int&gt; C;</span><br><span class="hljs-comment">    int t = 0;</span><br><span class="hljs-comment">    for (int i = 0; i &lt; A.size() || i &lt; B.size(); i ++ )</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        if (i &lt; A.size()) t += A[i];</span><br><span class="hljs-comment">        if (i &lt; B.size()) t += B[i];</span><br><span class="hljs-comment">        C.push_back(t % 10);</span><br><span class="hljs-comment">        t /= 10;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    if (t) C.push_back(t);</span><br><span class="hljs-comment">    return C;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="两个比较大的整数相减a-b">3. 两个比较大的整数相减<code>A-B</code></h2><h3 id="实现原理-1">3.1 实现原理</h3><p><img src="https://s1.ax1x.com/2023/07/14/pC4xk4J.png" style="zoom:100%;"></p><p><strong>(1) 两步实现：</strong></p><ol type="1"><li><p>判断<code>A</code>和<code>B</code>的大小。如果<code>A&gt;=B</code>，直接算<code>A-B</code>；如果<code>A&lt;B</code>，计算<code>B-A</code>后加上负号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断是否有 A &gt;= B</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span>(A[i] != B[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<span class="hljs-comment">// A &gt; B</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// A = B</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算<code>A-B</code></p></li></ol><p><strong>(2) 对于每一位的计算：</strong>需要计算<span class="math inline">\(A_i-B_i-t\)</span>，其中<span class="math inline">\(A_i\)</span>是被减数的第<span class="math inline">\(i\)</span>位、<span class="math inline">\(B_i\)</span>是减数的第<span class="math inline">\(i\)</span>位、<span class="math inline">\(t\)</span>是上一位借位。最初状态时，<span class="math inline">\(t\)</span>被赋初值<span class="math inline">\(0\)</span>，相当于向最低位的借位为<span class="math inline">\(0\)</span>。如果其结果<code>&gt;=0</code>，则直接为该位的计算结果；如果其结果<code>&lt;0</code>，则说明该位不够减，应该向上一位借位，从而在结果上<code>+10</code>。<span class="math inline">\(t\)</span>根据借位与否，决定其之后的值是1还是0。</p><h3 id="代码模板-1">3.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 去掉前导0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一个大整数乘一个小整数aa">4. 一个大整数乘一个小整数<code>A*a</code></h2><h3 id="实现原理-2">4.1 实现原理</h3><p>对于每一位的计算：分别计算当前位于乘数的乘积。计算 <span class="math inline">\((A_i*b+t)\%10\)</span> 作为当前位的计算结果，<span class="math inline">\((A_i+b+t)/10\)</span> 作为当前位的进位，并赋值给 <span class="math inline">\(t\)</span>。其中，<span class="math inline">\(A\)</span> 是乘数（大整数）、<span class="math inline">\(b\)</span> 是小整数、<span class="math inline">\(t\)</span> 是上一位的进位。</p><h3 id="代码模板-2">4.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<span class="hljs-comment">// 当前位的计算结果</span><br>        t /= <span class="hljs-number">10</span>;<span class="hljs-comment">// 进位</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一个大整数除以一个小整数ab">5. 一个大整数除以一个小整数<code>A/b</code></h2><h3 id="实现原理-3">5.1 实现原理</h3><p>模拟<strong>人工除法</strong>的过程：定义被除数为 <span class="math inline">\(A\)</span>（大整数）、除数为 <span class="math inline">\(b\)</span>（小整数）、余数 <span class="math inline">\(r\)</span>（小整数），初始时 <span class="math inline">\(r\)</span> 的值定义的 <span class="math inline">\(0\)</span>。计算每一位的时候，<span class="math inline">\((r*10+A_i)/b\)</span> 作为当前位的商，<span class="math inline">\((r*10+A_i)\%b\)</span> 作为当前位的余数。</p><p>计算结束后，由于计算结果不满足倒序存储，因此需要调用<code>reverse(C.begin(), C.end())</code>反转存储结果，使结果满足倒序存储。</p><h3 id="代码模板-3">5.2 代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度加法</tag>
      
      <tag>高精度减法</tag>
      
      <tag>高精度乘法</tag>
      
      <tag>高精度除法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2023/07/01/%E4%BA%8C%E5%88%86/"/>
    <url>/2023/07/01/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二分">二分</h1><p>二分的本质不是单调性。有单调性的题目一定可以二分，可以二分的题目不一定必须有单调性。</p><h2 id="整数二分">1. 整数二分</h2><p><img src="https://s1.ax1x.com/2023/07/14/pC4vynK.png" style="zoom:80%;"></p><h3 id="主要思想">1.1 主要思想</h3><p>在一个区间内部，使用二分的方法得到答案。每次选择答案所在的区间进行二分，且每次都能保证区间内有答案。对于有解的问题，二分得到的是正确答案；对于无解的题目，二分得到的是答案应该存在的位置。</p><h3 id="整数二分的实现过程">1.2 整数二分的实现过程</h3><ol type="1"><li>找一个中间值，即<code>mid = (l + r) / 2</code></li><li>（假设判断的是红色的性质）每次判断一下中间值是否满足性质，即<code>if(check(mid))</code><ul><li>情况一：<code>true</code><ul><li>说明<code>mid</code>满足该性质，因此<code>ans</code>所在区间为<code>[mid, r]</code></li><li>更新方式：<code>l = mid</code></li></ul></li><li>情况二：<code>false</code><ul><li>说明<code>mid</code>不满足该性质，因此<code>ans</code>所在区间为<code>[l, mid - 1]</code></li><li>更新方式：<code>r = mid - 1</code></li></ul></li></ul></li><li>（假设判断的是绿色的性质）每次判断一下中间值是否满足性质，即<code>if(check(mid))</code><ul><li>情况一：<code>true</code><ul><li>说明<code>mid</code>满足该性质，因此<code>ans</code>所在区间为<code>[l, mid]</code></li><li>更新方式：<code>r = mid</code></li></ul></li><li>情况二：<code>false</code><ul><li>说明<code>mid</code>不满足该性质，因此<code>ans</code>所在区间为<code>[mid + 1, r]</code></li><li>更新方式：<code>l = mid + 1</code></li></ul></li></ul></li></ol><blockquote><p><strong>中间值“是否+1”的问题</strong></p><p>如果<code>mid = (l + r) / 2</code>，当<code>l = r - 1</code>时，求得<code>mid</code>的值为<code>l</code>，倘若此时<code>check()</code>正好取得<code>true</code>，则会执行<code>l = mid</code>，即<code>l</code>更新后的值还是<code>l</code>，就会陷入死循环状态。</p></blockquote><h3 id="模板">1.3 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分">2. 浮点数二分</h2><h3 id="浮点数二分的实现过程">2.1 浮点数二分的实现过程</h3><p><img src="https://s1.ax1x.com/2023/07/14/pC4vrX6.png" style="zoom:80%;"></p><p>由于浮点数除法的结果仍然是浮点数，是保留精度的，其与整数除法的整除存在一定的差异。因此，浮点数二分不用考虑<strong>边界问题</strong>，其能够准确的把两个区间分为两部分。</p><h3 id="模板-1">2.2 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<span class="hljs-comment">// 注意是大-小, 或者直接用abs()函数取绝对值</span><br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>经验</strong>：如果题目要求保留4位小数，则<code>r-l</code>应该小于<code>1e-6</code>；如果题目要求保留5位小数，则<code>r-l</code>应该小于<code>1e-7</code>；如果题目要求保留6位小数，则<code>r-l</code>应该小于<code>1e-8</code>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整数二分</tag>
      
      <tag>浮点数二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2023/06/29/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/06/29/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序">归并排序</h1><h2 id="主要思想">1. 主要思想</h2><p>归并排序算法的主要思想：<strong>分治</strong></p><h2 id="归并排序的步骤">2. 归并排序的步骤</h2><ol type="1"><li><p>确定分界点</p><ul><li><p>以数组的中间位置为分界点，分为左右两部分。</p></li><li><p><code>mid = (l + r) / 2</code></p></li></ul></li><li><p>递归排序左右两部分</p><ul><li>递归左右两部分，对最小的单位进行排序</li></ul></li><li><p>归并——合二为一<strong>（重难点）</strong></p><ul><li>把两个有序的数组合并为一个有序的数组</li></ul></li></ol><ul><li><strong>时空复杂度：</strong><ul><li>时间复杂度：<span class="math inline">\(O(nlog_2n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ul></li></ul><h2 id="实现过程双指针算法">3. 实现过程（双指针算法）</h2><p><img src="https://s1.ax1x.com/2023/07/14/pC4vPfA.png"></p><blockquote><p>图片摘自：http://t.csdn.cn/RNb0o</p></blockquote><h2 id="模板">4. 模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前区间是否只有一个数或者没有数</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-comment">// 排序当前数组</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++] = q[j++];<br>    <span class="hljs-comment">// 处理某数组的元素全部排序完成，另一个数组中包含元素的情况</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];<br>    <span class="hljs-comment">// 把临时数组中排好序的内容转移到要排序的数组</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2023/06/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/06/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序">快速排序</h1><h2 id="主要思想">1. 主要思想</h2><p>快速排序算法的主要思想：<strong>分治</strong></p><h2 id="快速排序的步骤">2. 快速排序的步骤</h2><ol type="1"><li>确定分界点<code>x</code><ul><li>确定一个分界点，用于将数组划分为两个子数组</li><li>常用方式：取边界（<code>q[l]</code>或<code>q[r]</code>）、取中间值（<code>q[(l+r)/2]</code>）、取区间内随机一个数</li></ul></li><li>调整区间<strong>（重难点）</strong><ul><li>根据分界点，把区间分为两部分，使得左边区间的数都<code>&lt;=x</code>，右边区间的数都<code>&gt;=x</code></li></ul></li><li>递归处理左右两段区间</li></ol><p><img src="https://s1.ax1x.com/2023/07/14/pC4LFqe.png"></p><h2 id="如何调整区间">3. 如何调整区间</h2><h3 id="方法一暴力法思想简单占用额外空间">方法一：暴力法（思想简单、占用额外空间）</h3><ul><li><strong>基本思想：</strong><ul><li><p>首先，开两个额外的数组<code>a[]</code>、<code>b[]</code>。</p></li><li><p>然后，扫描<code>q[l] ~ q[r]</code>的每一个数。如果<code>q[i]&lt;=x</code>，则把其插入到数组<code>a[]</code>中；如果<code>q[i]&gt;x</code>，则把其插入到数组<code>b[]</code>中。</p></li><li><p>最后，先遍历数组<code>a[]</code>，再遍历数组<code>b[]</code>，把数组中的数依次存储到数组<code>q[]</code>中。</p></li></ul></li><li><strong>时空复杂度：</strong><ul><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li><li>空间复杂度：<span class="math inline">\(O(n)\)</span></li></ul></li></ul><h3 id="方法二双指针法优美而简洁">方法二：双指针法（优美而简洁）</h3><blockquote><p><strong>要点：</strong>在任何时刻，<code>i</code>指针左边所有的数都一定<code>&lt;=x</code>，<code>j</code>指针右边的数都一定<code>&gt;=x</code>。</p><p><strong>原因：</strong>当<code>i</code>指针在遍历时，如果当前数满足<code>&lt;x</code>的条件时，则<code>i</code>会指向下一个数；如果当前数不满足<code>&lt;x</code>的条件时，<code>i</code>指针会等待<code>j</code>指针找到一个<code>&gt;=x</code>的数与之交换，从而使得当前数也满足<code>&lt;=x</code>的条件。最终，<code>i</code>指针左侧所有的数都一定<code>&lt;=x</code>。对于<code>j</code>指针，同理。</p></blockquote><ul><li><p><strong>基本思想：</strong></p><ul><li><p>定义两个指针<code>i</code>和<code>j</code>，分别指向要排序的数组<code>q</code>的两端</p><p><img src="https://s1.ax1x.com/2023/07/14/pC4LirD.png" alt="pC4LirD.png"></p></li><li><p>两个指针分别往中间走，即<code>i++</code>和<code>j--</code>。</p><ul><li><p>首先，移动<code>i</code>指针。当<code>i</code>指向的值满足<code>q[i]&lt;x</code>时，<code>i</code>做自增运算，即<code>i++</code>；否则，<code>i</code>指针停止移动。</p></li><li><p>然后，移动<code>j</code>指针。当<code>j</code>指向的值满足<code>q[j]&gt;x</code>时，<code>j</code>做自减运算，即<code>j--</code>；否则，<code>j</code>指针停止移动。</p><p><img src="https://s1.ax1x.com/2023/07/14/pC4LPKO.png" alt="pC4LPKO.png"></p></li></ul></li><li><p>做完上述指针移动操作后，<code>i</code>指针左边所有的值都满足<code>q[]&lt;x</code>，<code>j</code>指针右边所有的值都满足<code>q[]&gt;x</code>，但此时<code>q[i]&gt;=x</code>且<code>q[j]&lt;=x</code>。为满足要求（调整区间），需要通过交换<code>i</code>和<code>j</code>指向的值，使得<code>i</code>指向的值满足<code>q[i]&lt;=x</code>、<code>j</code>指向的值满足<code>q[j]&gt;=x</code>，从而使程序能够继续运行。</p><p><img src="https://s1.ax1x.com/2023/07/14/pC4LmGt.png" alt="pC4LmGt.png"></p></li><li><p>当<code>i&gt;j</code>时，说明已经得到了两端调整后的区间（此时，<code>i</code>指针左边的值都满足小于等于x，<code>j</code>指针右边的值都满足大于等于x）</p><p><img src="https://s1.ax1x.com/2023/07/14/pC4L9xK.png" alt="pC4L9xK.png"></p></li></ul></li><li><p><strong>时空复杂度：</strong></p></li><li><p>时间复杂度：<span class="math inline">\(O(nlog_2n)\)</span></p></li><li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li></ul><h2 id="模板">4. 模板</h2><h3 id="模板-1">(1) 模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 模板1☆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前要排序的子数组中的元素个数是否&lt;=1</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 调整区间</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<span class="hljs-comment">// 这里尽量用 j</span><br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-comment">// 模板2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前要排序的子数组中的元素个数是否&lt;=1</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 调整区间</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-comment">// 递归排序子数组</span><br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关于边界问题">(2) 关于边界问题</h3><p><strong>正确代码1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<span class="hljs-comment">// 或者x = q[(l+r)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/14/pC4LAVH.png"></p><p><strong>错误代码1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[r];<span class="hljs-comment">// 或者x = q[(l+r)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);<br>    <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/14/pC4LEad.png"></p><p><strong>正确代码2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[r];<span class="hljs-comment">// 或者x = q[(l+r+1)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/14/pC4LVIA.png"></p><p><strong>错误代码2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l];<span class="hljs-comment">// 或者x = q[(l+r+1)/2]</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quick_sort</span>(q, i, r);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/07/14/pC4LePI.png"></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
